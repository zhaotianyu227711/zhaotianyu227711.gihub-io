/*Copyright (c) 2012-2014 Brian Chirls

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/
! function(root, factory) {
	"use strict";
	"function" == typeof define && define.amd ? define("seriously", function() {
		var Seriously = factory(root);
		return root.Seriously || (root.Seriously = Seriously), Seriously
	}) : "object" == typeof exports ? module.exports = factory(root) : "function" != typeof root.Seriously && (root.Seriously = factory(root))
}(window, function(window) {
	"use strict";
	var testContext, colorCtx, incompatibility, identity, noVideoTextureSupport, baseVertexShader, baseFragmentShader, lastTime, document = window.document,
		console = window.console,
		seriousEffects = {},
		seriousTransforms = {},
		seriousSources = {},
		seriousTargets = {},
		timeouts = [],
		allEffectsByHook = {},
		allTransformsByHook = {},
		allSourcesByHook = {
			canvas: [],
			image: [],
			video: []
		},
		allTargetsByHook = {},
		allTargets = window.WeakMap && new WeakMap,
		maxSeriouslyId = 0,
		nop = function() {},
		colorNames = {
			transparent: [0, 0, 0, 0],
			black: [0, 0, 0, 1],
			red: [1, 0, 0, 1],
			green: [0, 128 / 255, 0, 1],
			blue: [0, 0, 1, 1],
			white: [1, 1, 1, 1],
			silver: [192 / 255, 192 / 255, 192 / 255, 1],
			gray: [128 / 255, 128 / 255, 128 / 255, 1],
			maroon: [128 / 255, 0, 0, 1],
			purple: [128 / 255, 0, 128 / 255, 1],
			fuchsia: [1, 0, 1, 1],
			lime: [0, 1, 0, 1],
			olive: [128 / 255, 128 / 255, 0, 1],
			yellow: [1, 1, 0, 1],
			navy: [0, 0, 128 / 255, 1],
			teal: [0, 128 / 255, 128 / 255, 1],
			aqua: [0, 1, 1, 1],
			orange: [1, 165 / 255, 0, 1]
		},
		colorRegex = /^(rgb|hsl)a?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*(\d+(\.\d*)?)\s*)?\)/i,
		hexColorRegex = /^#(([0-9a-fA-F]{3,8}))/,
		vectorFields = ["x", "y", "z", "w"],
		colorFields = ["r", "g", "b", "a"],
		outputRenderOptions = {
			srcRGB: 770,
			dstRGB: 771,
			srcAlpha: 1,
			dstAlpha: 771
		},
		shaderDebugConstants = ["MAX_COMBINED_TEXTURE_IMAGE_UNITS", "MAX_FRAGMENT_UNIFORM_VECTORS", "MAX_TEXTURE_IMAGE_UNITS", "MAX_VARYING_VECTORS", "MAX_VERTEX_ATTRIBS", "MAX_VERTEX_TEXTURE_IMAGE_UNITS", "MAX_VERTEX_UNIFORM_VECTORS"],
		shaderNameRegex = /^[\t ]*#define[\t ]+SHADER_NAME\s+([^$\n\r]+)/i,
		mat4 = {
			frustum: function(left, right, bottom, top, near, far, dest) {
				dest || (dest = mat4.create());
				var rl = right - left,
					tb = top - bottom,
					fn = far - near;
				return dest[0] = 2 * near / rl, dest[1] = 0, dest[2] = 0, dest[3] = 0, dest[4] = 0, dest[5] = 2 * near / tb, dest[6] = 0, dest[7] = 0, dest[8] = (right + left) / rl, dest[9] = (top + bottom) / tb, dest[10] = -(far + near) / fn, dest[11] = -1, dest[12] = 0, dest[13] = 0, dest[14] = -far * near * 2 / fn, dest[15] = 0, dest
			},
			perspective: function(fovy, aspect, near, far, dest) {
				var top = near * Math.tan(fovy * Math.PI / 360),
					right = top * aspect;
				return mat4.frustum(-right, right, -top, top, near, far, dest)
			},
			multiply: function(dest, mat, mat2) {
				var a00 = mat[0],
					a01 = mat[1],
					a02 = mat[2],
					a03 = mat[3],
					a10 = mat[4],
					a11 = mat[5],
					a12 = mat[6],
					a13 = mat[7],
					a20 = mat[8],
					a21 = mat[9],
					a22 = mat[10],
					a23 = mat[11],
					a30 = mat[12],
					a31 = mat[13],
					a32 = mat[14],
					a33 = mat[15],
					b0 = mat2[0],
					b1 = mat2[1],
					b2 = mat2[2],
					b3 = mat2[3];
				return dest[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, dest[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, dest[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, dest[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = mat2[4], b1 = mat2[5], b2 = mat2[6], b3 = mat2[7], dest[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, dest[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, dest[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, dest[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = mat2[8], b1 = mat2[9], b2 = mat2[10], b3 = mat2[11], dest[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, dest[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, dest[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, dest[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = mat2[12], b1 = mat2[13], b2 = mat2[14], b3 = mat2[15], dest[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, dest[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, dest[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, dest[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, dest
			},
			identity: function(dest) {
				return dest[0] = 1, dest[1] = 0, dest[2] = 0, dest[3] = 0, dest[4] = 0, dest[5] = 1, dest[6] = 0, dest[7] = 0, dest[8] = 0, dest[9] = 0, dest[10] = 1, dest[11] = 0, dest[12] = 0, dest[13] = 0, dest[14] = 0, dest[15] = 1, dest
			},
			copy: function(out, a) {
				return out[0] = a[0], out[1] = a[1], out[2] = a[2], out[3] = a[3], out[4] = a[4], out[5] = a[5], out[6] = a[6], out[7] = a[7], out[8] = a[8], out[9] = a[9], out[10] = a[10], out[11] = a[11], out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15], out
			}
		},
		requestAnimationFrame = (lastTime = 0, window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
			var currTime, timeToCall, id;
			return currTime = (new Date).getTime(), timeToCall = Math.max(0, 16 - (currTime - lastTime)), id = window.setTimeout(function() {
				callback(currTime + timeToCall)
			}, timeToCall), lastTime = currTime + timeToCall, id
		}),
		cancelAnimFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function(id) {
			window.cancelTimeout(id)
		},
		reservedEffectProperties = ["alias", "destroy", "effect", "id", "initialize", "inputs", "isDestroyed", "isReady", "matte", "off", "on", "readPixels", "render", "title", "update"],
		reservedTransformProperties = ["alias", "destroy", "id", "inputs", "isDestroyed", "isReady", "off", "on", "source", "title", "update"],
		reservedNames = ["aliases", "defaults", "destroy", "effect", "go", "id", "incompatible", "isDestroyed", "isEffect", "isNode", "isSource", "isTarget", "isTransform", "removeAlias", "render", "source", "stop", "target", "transform"];

	function getElement(input, tags) {
		var element, tag;
		if ("string" == typeof input) element = document.querySelector(input);
		else if (!input) return !1;
		return input.tagName && (element = input), element ? (tag = element.tagName.toLowerCase(), tags && tags.indexOf(tag) < 0 ? input : element) : input
	}

	function extend(dest, src) {
		var property, descriptor;
		for (property in dest.prototype && src.prototype && dest.prototype !== src.prototype && extend(dest.prototype, src.prototype), src) src.hasOwnProperty(property) && ((descriptor = Object.getOwnPropertyDescriptor(src, property)).get || descriptor.set ? Object.defineProperty(dest, property, {
			configurable: !0,
			enumerable: !0,
			get: descriptor.get,
			set: descriptor.set
		}) : dest[property] = src[property]);
		return dest
	}

	function consoleMethod(name) {
		var method;
		if (!console) return nop;
		if ("function" == typeof console[name]) method = console[name];
		else {
			if ("function" != typeof console.log) return nop;
			method = console.log
		}
		return method.bind ? method.bind(console) : function() {
			method.apply(console, arguments)
		}
	}

	function isInstance(obj, proto) {
		if (proto || (proto = "HTMLElement"), obj instanceof window[proto]) return !0;
		if (!obj || "object" != typeof obj) return !1;
		for (; obj;)
			if ((obj = Object.getPrototypeOf(obj)) && obj.constructor.name === proto) return !0;
		return !1
	}

	function hslToRgb(h, s, l, a, out) {
		function hueToRgb(m1, m2, h) {
			return (h %= 1) < 0 && (h += 1), h < 1 / 6 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h < 2 / 3 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1
		}
		var m1, m2;
		return m1 = 2 * l - (m2 = l < .5 ? l * (s + 1) : l + s - l * s), out || (out = []), out[0] = hueToRgb(m1, m2, h + 1 / 3), out[1] = hueToRgb(m1, m2, h), out[2] = hueToRgb(m1, m2, h - 1 / 3), out[3] = a, out
	}

	function colorArrayToHex(color) {
		var i, val, hex, s = "#",
			len = color[3] < 1 ? 4 : 3;
		for (i = 0; i < len; i++) hex = (val = Math.min(255, Math.round(255 * color[i] || 0))).toString(16), val < 16 && (hex = "0" + hex), s += hex;
		return s
	}

	function isArrayLike(obj) {
		return Array.isArray(obj) || obj && obj.BYTES_PER_ELEMENT && "length" in obj
	}

	function setTimeoutZero(fn) {
		if ("function" != typeof fn) throw new Error("setTimeoutZero argument is not a function");
		timeouts.push(fn), "file:" !== window.location.protocol ? window.postMessage("seriously-timeout-message", window.location) : setTimeout(function() {
			timeouts.length && timeouts.shift()()
		}, 0)
	}

	function getWebGlContext(canvas, options) {
		var context;
		try {
			context = window.WebGLDebugUtils && options && options.debugContext ? window.WebGLDebugUtils.makeDebugContext(canvas.getContext("webgl", options)) : canvas.getContext("webgl", options)
		} catch (expError) {}
		if (!context) try {
			context = canvas.getContext("experimental-webgl", options)
		} catch (error) {}
		return context
	}

	function getTestContext() {
		var canvas;
		return testContext && testContext.getError() === testContext.CONTEXT_LOST_WEBGL && (testContext = void 0), testContext || !window.WebGLRenderingContext || incompatibility || (canvas = document.createElement("canvas"), (testContext = getWebGlContext(canvas)) ? canvas.addEventListener("webglcontextlost", function contextLost(event) {
			event.preventDefault(), testContext && testContext.canvas === this && (testContext = void 0, canvas.removeEventListener("webglcontextlost", contextLost, !1))
		}, !1) : Seriously.logger.warn("Unable to access WebGL.")), testContext
	}

	function validateInputSpecs(plugin) {
		var input, options, name;

		function normalizeEnumOption(option, i) {
			var key, name;
			isArrayLike(option) ? (key = option[0], name = option[1] || key) : key = option, "string" == typeof key ? key = key.toLowerCase() : "number" == typeof key ? key = String(key) : key || (key = ""), options[key] = name, i || (input.firstValue = key)
		}

		function passThrough(value) {
			return value
		}
		for (name in plugin.inputs)
			if (plugin.inputs.hasOwnProperty(name)) {
				if (0 <= plugin.reserved.indexOf(name) || Object.prototype[name]) throw new Error("Reserved input name: " + name);
				(input = plugin.inputs[name]).name = name, isNaN(input.min) && (input.min = -1 / 0), isNaN(input.max) && (input.max = 1 / 0), isNaN(input.minCount) && (input.minCount = -1 / 0), isNaN(input.maxCount) && (input.maxCount = 1 / 0), isNaN(input.step) && (input.step = 0), isNaN(input.mod) && (input.mod = 0), "enum" === input.type && input.options && isArrayLike(input.options) && input.options.length && (options = {}, input.options.forEach(normalizeEnumOption), input.options = options), "vector" === input.type ? input.dimensions < 2 ? input.dimensions = 2 : 4 < input.dimensions ? input.dimensions = 4 : !input.dimensions || isNaN(input.dimensions) ? input.dimensions = 4 : input.dimensions = Math.round(input.dimensions) : input.dimensions = 1, input.shaderDirty = !!input.shaderDirty, "function" != typeof input.validate && (input.validate = Seriously.inputValidators[input.type] || passThrough), plugin.defaultImageInput || "image" !== input.type || (plugin.defaultImageInput = name)
			}
	}

	function FrameBuffer(gl, width, height, options) {
		var frameBuffer, renderBuffer, tex, status;
		!0 === options || options && options.useFloat;
		this.type = gl.UNSIGNED_BYTE, frameBuffer = gl.createFramebuffer(), gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer), options && options.texture ? (this.texture = options.texture, gl.bindTexture(gl.TEXTURE_2D, this.texture), this.ownTexture = !1) : (this.texture = gl.createTexture(), gl.bindTexture(gl.TEXTURE_2D, this.texture), gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE), this.ownTexture = !0);
		try {
			this.type === gl.FLOAT ? (tex = new Float32Array(width * height * 4), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, tex)) : (gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null), this.type = gl.UNSIGNED_BYTE)
		} catch (e) {
			this.type = gl.UNSIGNED_BYTE, tex = new Uint8Array(width * height * 4), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, tex)
		}
		if (renderBuffer = gl.createRenderbuffer(), gl.bindRenderbuffer(gl.RENDERBUFFER, renderBuffer), gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderBuffer), gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0), (status = gl.checkFramebufferStatus(gl.FRAMEBUFFER)) === gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT) throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
		if (status === gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT) throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
		if (status === gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS) throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
		if (status === gl.FRAMEBUFFER_UNSUPPORTED) throw new Error("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
		if (status !== gl.FRAMEBUFFER_COMPLETE) throw new Error("Incomplete framebuffer: " + status);
		gl.bindTexture(gl.TEXTURE_2D, null), gl.bindRenderbuffer(gl.RENDERBUFFER, null), gl.bindFramebuffer(gl.FRAMEBUFFER, null), this.gl = gl, this.frameBuffer = frameBuffer, this.renderBuffer = renderBuffer, this.width = width, this.height = height
	}

	function ShaderProgram(gl, vertexShaderSource, fragmentShaderSource) {
		var program, vertexShader, fragmentShader, shaderError, i, l, shaderNameRegexMatch, obj, programError = "";

		function compileShader(source, fragment) {
			var shader, j;
			if (shader = fragment ? gl.createShader(gl.FRAGMENT_SHADER) : gl.createShader(gl.VERTEX_SHADER), gl.shaderSource(shader, source), gl.compileShader(shader), gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader;
			for (source = source.split(/[\n\r]/), j = 0; j < source.length; j++) source[j] = j + 1 + ":\t" + source[j];
			throw source.unshift("Error compiling " + (fragment ? "fragment" : "vertex") + " shader:"), Seriously.logger.error(source.join("\n")), new Error("Shader error: " + gl.getShaderInfoLog(shader))
		}

		function makeShaderSetter(info, loc) {
			if (info.type === gl.SAMPLER_2D) return function(value) {
				info.glTexture = gl["TEXTURE" + value], gl.uniform1i(loc, value)
			};
			if (info.type === gl.BOOL || info.type === gl.INT) return 1 < info.size ? function(value) {
				gl.uniform1iv(loc, value)
			} : function(value) {
				gl.uniform1i(loc, value)
			};
			if (info.type === gl.FLOAT) return 1 < info.size ? function(value) {
				gl.uniform1fv(loc, value)
			} : function(value) {
				gl.uniform1f(loc, value)
			};
			if (info.type === gl.FLOAT_VEC2) return function(obj) {
				gl.uniform2f(loc, obj[0], obj[1])
			};
			if (info.type === gl.FLOAT_VEC3) return function(obj) {
				gl.uniform3f(loc, obj[0], obj[1], obj[2])
			};
			if (info.type === gl.FLOAT_VEC4) return function(obj) {
				gl.uniform4f(loc, obj[0], obj[1], obj[2], obj[3])
			};
			if (info.type === gl.FLOAT_MAT3) return function(mat3) {
				gl.uniformMatrix3fv(loc, !1, mat3)
			};
			if (info.type === gl.FLOAT_MAT4) return function(mat4) {
				gl.uniformMatrix4fv(loc, !1, mat4)
			};
			throw new Error("Unknown shader uniform type: " + info.type)
		}

		function makeShaderGetter(loc) {
			return function() {
				return gl.getUniform(program, loc)
			}
		}
		if (vertexShader = compileShader(vertexShaderSource), fragmentShader = compileShader(fragmentShaderSource, !0), program = gl.createProgram(), gl.attachShader(program, vertexShader), (shaderError = gl.getShaderInfoLog(vertexShader)) && (programError += "Vertex shader error: " + shaderError + "\n"), gl.attachShader(program, fragmentShader), (shaderError = gl.getShaderInfoLog(fragmentShader)) && (programError += "Fragment shader error: " + shaderError + "\n"), gl.linkProgram(program), !gl.getProgramParameter(program, gl.LINK_STATUS)) throw programError += gl.getProgramInfoLog(program), gl.deleteProgram(program), gl.deleteShader(vertexShader), gl.deleteShader(fragmentShader), (shaderNameRegexMatch = shaderNameRegex.exec(vertexShaderSource) || shaderNameRegex.exec(fragmentShaderSource)) && (programError = "Shader = " + shaderNameRegexMatch[1] + "\n" + programError), shaderDebugConstants.forEach(function(c) {
			programError += "\n" + c + ": " + gl.getParameter(gl[c])
		}), new Error("Could not initialize shader:\n" + programError);
		for (gl.useProgram(program), this.uniforms = {}, l = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS), i = 0; i < l; ++i)(obj = {
			info: gl.getActiveUniform(program, i)
		}).name = obj.info.name.replace(/\[0\]$/, ""), obj.loc = gl.getUniformLocation(program, obj.name), obj.set = makeShaderSetter(obj.info, obj.loc), obj.get = makeShaderGetter(obj.loc), this.uniforms[obj.name] = obj, this[obj.name] || (this[obj.name] = obj);
		for (this.attributes = {}, this.location = {}, l = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES), i = 0; i < l; ++i)(obj = {
			info: gl.getActiveAttrib(program, i)
		}).name = obj.info.name, obj.location = gl.getAttribLocation(program, obj.name), this.attributes[obj.name] = obj, this.location[obj.name] = obj.location;
		this.gl = gl, this.program = program, this.destroy = function() {
			var key;
			for (key in gl && (gl.deleteProgram(program), gl.deleteShader(vertexShader), gl.deleteShader(fragmentShader)), this) this.hasOwnProperty(key) && delete this[key];
			fragmentShader = vertexShader = program = null
		}
	}

	function Seriously(options) {
		if (window === this || !(this instanceof Seriously) || void 0 !== this.id) return new Seriously(options);
		var glCanvas, gl, primaryTarget, rectangleModel, baseShader, Node, SourceNode, EffectNode, TransformNode, TargetNode, Effect, Source, Transform, Target, rafId, id = ++maxSeriouslyId,
			seriously = this,
			nodes = [],
			nodesById = {},
			nodeId = 0,
			sources = [],
			targets = [],
			transforms = [],
			effects = [],
			aliases = {},
			preCallbacks = [],
			postCallbacks = [],
			defaultInputs = {},
			commonShaders = {},
			auto = !1,
			isDestroyed = !1;

		function makeGlModel(shape, gl) {
			var vertex, index, texCoord;
			return !!gl && (vertex = gl.createBuffer(), gl.bindBuffer(gl.ARRAY_BUFFER, vertex), gl.bufferData(gl.ARRAY_BUFFER, shape.vertices, gl.STATIC_DRAW), vertex.size = 3, index = gl.createBuffer(), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index), gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, shape.indices, gl.STATIC_DRAW), texCoord = gl.createBuffer(), gl.bindBuffer(gl.ARRAY_BUFFER, texCoord), gl.bufferData(gl.ARRAY_BUFFER, shape.coords, gl.STATIC_DRAW), texCoord.size = 2, {
				vertex: vertex,
				index: index,
				texCoord: texCoord,
				length: shape.indices.length,
				mode: shape.mode || gl.TRIANGLES
			})
		}

		function buildRectangleModel(gl) {
			var shape = {};
			return shape.vertices = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0]), shape.indices = new Uint16Array([0, 1, 2, 0, 2, 3]), shape.coords = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), makeGlModel(shape, gl)
		}

		function attachContext(context) {
			var i, node;
			if (!gl)
				if (context.canvas.addEventListener("webglcontextlost", destroyContext, !1), context.canvas.addEventListener("webglcontextrestored", restoreContext, !1), context.isContextLost()) Seriously.logger.warn("Unable to attach lost WebGL context. Will try again when context is restored.");
				else {
					for (glCanvas = (gl = context).canvas, rectangleModel = buildRectangleModel(gl), baseShader = new ShaderProgram(gl, "#define SHADER_NAME seriously.base\n" + baseVertexShader, "#define SHADER_NAME seriously.base\n" + baseFragmentShader), i = 0; i < effects.length; i++)(node = effects[i]).gl = gl, node.initialize(), node.buildShader();
					for (i = 0; i < sources.length; i++)(node = sources[i]).initialize();
					for (i = 0; i < targets.length; i++)(node = targets[i]).model || (node.model = rectangleModel, node.shader = baseShader)
				}
		}

		function restoreContext() {
			var context, target, i, node;
			if (primaryTarget && !gl) {
				if (isInstance(target = primaryTarget.target, "WebGLFramebuffer")) return void Seriously.logger.error("Unable to restore target built on WebGLFramebuffer");
				if (context = getWebGlContext(target, {
						alpha: !0,
						premultipliedAlpha: !0,
						preserveDrawingBuffer: !0,
						stencil: !0,
						debugContext: primaryTarget.debugContext
					})) {
					if (context.isContextLost()) return void Seriously.logger.error("Unable to restore WebGL Context");
					for (attachContext(context), primaryTarget.renderToTexture ? primaryTarget.frameBuffer = new FrameBuffer(gl, primaryTarget.width, primaryTarget.height, !1) : primaryTarget.frameBuffer = {
							frameBuffer: null
						}, i = 0; i < nodes.length; i++)(node = nodes[i]).setDirty(), node.emit("webglcontextrestored");
					Seriously.logger.log("WebGL context restored")
				}
			}
		}

		function destroyContext(event) {
			var i, node;
			for (event && (Seriously.logger.warn("WebGL context lost"), event.preventDefault()), rafId && (cancelAnimFrame(rafId), rafId = 0), glCanvas && glCanvas.removeEventListener("webglcontextlost", destroyContext, !1), i = 0; i < effects.length; i++)(node = effects[i]).gl = null, node.initialized = !1, node.baseShader = null, node.model = null, node.frameBuffer = null, node.texture = null, node.shader && node.shader.destroy && (node.shader.destroy(), node.effect.commonShader && delete commonShaders[node.hook]), node.shaderDirty = !0, node.shader = null, node.effect.lostContext && node.effect.lostContext.call(node), event && node.emit("webglcontextlost");
			for (i = 0; i < sources.length; i++)(node = sources[i]).texture = null, node.initialized = !1, node.allowRefresh = !1, event && node.emit("webglcontextlost");
			for (i = 0; i < transforms.length; i++)(node = transforms[i]).frameBuffer = null, node.texture = null, event && node.emit("webglcontextlost");
			for (i = 0; i < targets.length; i++)(node = targets[i]).model = !1, node.frameBuffer = null, event && node.emit("webglcontextlost");
			baseShader && baseShader.destroy && baseShader.destroy(), gl && (gl.deleteBuffer(rectangleModel.vertex), gl.deleteBuffer(rectangleModel.texCoord), gl.deleteBuffer(rectangleModel.index)), rectangleModel && (delete rectangleModel.vertex, delete rectangleModel.texCoord, delete rectangleModel.index), glCanvas = gl = baseShader = rectangleModel = null
		}

		function renderDaemon(now) {
			var i, node, keepRunning = !1;
			if (rafId = 0, preCallbacks.length)
				for (keepRunning = !0, i = 0; i < preCallbacks.length; i++) preCallbacks[i].call(seriously, now);
			if (sources && sources.length)
				for (keepRunning = !0, i = 0; i < sources.length; i++)((node = sources[i]).dirty || node.checkDirty && node.checkDirty()) && (node.dirty = !1, node.setDirty());
			for (i = 0; i < targets.length; i++)(node = targets[i]).auto && node.dirty && node.render();
			if (postCallbacks.length)
				for (keepRunning = !0, i = 0; i < postCallbacks.length; i++) postCallbacks[i].call(seriously);
			keepRunning && !rafId && (rafId = requestAnimationFrame(renderDaemon))
		}

		function draw(shader, model, uniforms, frameBuffer, node, options) {
			var name, value, shaderUniform, width, height, srcRGB, srcAlpha, dstRGB, dstAlpha, numTextures = 0,
				nodeGl = node && node.gl || gl;
			if (nodeGl) {
				for (name in height = node ? (width = options && options.width || node.width || nodeGl.canvas.width, options && options.height || node.height || nodeGl.canvas.height) : (width = options && options.width || nodeGl.canvas.width, options && options.height || nodeGl.canvas.height), shader.use(), nodeGl.viewport(0, 0, width, height), nodeGl.bindFramebuffer(nodeGl.FRAMEBUFFER, frameBuffer), nodeGl.enableVertexAttribArray(shader.location.position), nodeGl.enableVertexAttribArray(shader.location.texCoord), model.texCoord && (nodeGl.bindBuffer(nodeGl.ARRAY_BUFFER, model.texCoord), nodeGl.vertexAttribPointer(shader.location.texCoord, model.texCoord.size, nodeGl.FLOAT, !1, 0, 0)), nodeGl.bindBuffer(nodeGl.ARRAY_BUFFER, model.vertex), nodeGl.vertexAttribPointer(shader.location.position, model.vertex.size, nodeGl.FLOAT, !1, 0, 0), nodeGl.bindBuffer(nodeGl.ELEMENT_ARRAY_BUFFER, model.index), options && options.depth ? gl.enable(gl.DEPTH_TEST) : gl.disable(gl.DEPTH_TEST), options ? void 0 === options.blend || options.blend ? (gl.enable(gl.BLEND), srcRGB = void 0 === options.srcRGB ? gl.ONE : options.srcRGB, dstRGB = options.dstRGB || gl.ZERO, srcAlpha = void 0 === options.srcAlpha ? srcRGB : options.srcAlpha, dstAlpha = void 0 === options.dstAlpha ? dstRGB : options.dstAlpha, gl.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha), gl.blendEquation(options.blendEquation || gl.FUNC_ADD)) : gl.disable(gl.BLEND) : (gl.enable(gl.BLEND), gl.blendFunc(gl.ONE, gl.ZERO), gl.blendEquation(gl.FUNC_ADD)), uniforms) uniforms.hasOwnProperty(name) && (value = uniforms[name], (shaderUniform = shader.uniforms[name]) && (isInstance(value, "WebGLTexture") ? (nodeGl.activeTexture(nodeGl.TEXTURE0 + numTextures), nodeGl.bindTexture(nodeGl.TEXTURE_2D, value), shaderUniform.set(numTextures), numTextures++) : value instanceof SourceNode || value instanceof EffectNode || value instanceof TransformNode ? value.texture && (nodeGl.activeTexture(nodeGl.TEXTURE0 + numTextures), nodeGl.bindTexture(nodeGl.TEXTURE_2D, value.texture), shaderUniform.set(numTextures), numTextures++) : null != value && shaderUniform.set(value)));
				options && void 0 !== options.clear && !options.clear || (nodeGl.clearColor(0, 0, 0, 0), nodeGl.clear(nodeGl.COLOR_BUFFER_BIT | nodeGl.DEPTH_BUFFER_BIT)), nodeGl.drawElements(model.mode, model.length, nodeGl.UNSIGNED_SHORT, 0), gl.enable(gl.DEPTH_TEST)
			}
		}

		function findInputNode(hook, source, options) {
			var node, i;
			if (("string" != typeof hook || !source && 0 !== source) && (options && "object" == typeof options || (options = source), source = hook), "string" == typeof hook && seriousSources[hook] || (hook = null), source instanceof SourceNode || source instanceof EffectNode || source instanceof TransformNode) node = source;
			else if (source instanceof Effect || source instanceof Source || source instanceof Transform) {
				if (!(node = nodesById[source.id])) throw new Error("Cannot connect a foreign node")
			} else {
				for ("string" == typeof source && isNaN(source) && (source = getElement(source, ["canvas", "img", "video"])), i = 0; i < sources.length; i++)
					if (node = sources[i], (!hook || hook === node.hook) && node.compare && node.compare(source, options)) return node;
				node = new SourceNode(hook, source, options)
			}
			return node
		}

		function traceSources(node, original) {
			var i, source, nodeSources;
			if (!(node instanceof EffectNode || node instanceof TransformNode)) return !1;
			if (node === original) return !0;
			for (i in nodeSources = node.sources)
				if (nodeSources.hasOwnProperty(i) && ((source = nodeSources[i]) === original || traceSources(source, original))) return !0;
			return !1
		}(Node = function() {
			this.ready = !1, this.width = 1, this.height = 1, this.gl = gl, this.uniforms = {
				resolution: [this.width, this.height],
				transform: null
			}, this.dirty = !0, this.isDestroyed = !1, this.seriously = seriously, this.listeners = {}, this.id = nodeId, nodeId++
		}).prototype.setReady = function() {
			var i;
			if (!this.ready && (this.ready = !0, this.emit("ready"), this.targets))
				for (i = 0; i < this.targets.length; i++) this.targets[i].setReady()
		}, Node.prototype.setUnready = function() {
			var i;
			if (this.ready && (this.ready = !1, this.emit("unready"), this.targets))
				for (i = 0; i < this.targets.length; i++) this.targets[i].setUnready()
		}, Node.prototype.setDirty = function() {
			var i;
			if (!this.dirty && (this.emit("dirty"), this.dirty = !0, this.targets))
				for (i = 0; i < this.targets.length; i++) this.targets[i].setDirty()
		}, Node.prototype.initFrameBuffer = function(useFloat) {
			gl && (this.frameBuffer = new FrameBuffer(gl, this.width, this.height, useFloat))
		}, Node.prototype.readPixels = function(x, y, width, height, dest) {
			var nodeGl = this.gl || gl;
			if (!gl) throw new Error("Cannot read pixels until a canvas is connected");
			if (this.frameBuffer || (this.initFrameBuffer(), this.setDirty()), this.render(), void 0 === dest) dest = new Uint8Array(width * height * 4);
			else if (!isInstance(dest, "Uint8Array")) throw new Error("Incompatible array type");
			return nodeGl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer.frameBuffer), nodeGl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, dest), dest
		}, Node.prototype.resize = function() {
			var width, height;
			this.source ? (width = this.source.width, height = this.source.height) : this.sources && this.sources.source ? (width = this.sources.source.width, height = this.sources.source.height) : this.inputs && this.inputs.width ? (width = this.inputs.width, height = this.inputs.height || width) : this.inputs && this.inputs.height ? width = height = this.inputs.height : height = width = 1, width = Math.floor(width), height = Math.floor(height), this.width === width && this.height === height || (this.width = width, this.height = height, this.emit("resize"), this.setDirty()), this.uniforms && this.uniforms.resolution && (this.uniforms.resolution[0] = width, this.uniforms.resolution[1] = height), this.frameBuffer && this.frameBuffer.resize && this.frameBuffer.resize(width, height)
		}, Node.prototype.on = function(eventName, callback) {
			var listeners, index = -1;
			eventName && "function" == typeof callback && ((listeners = this.listeners[eventName]) ? index = listeners.indexOf(callback) : listeners = this.listeners[eventName] = [], index < 0 && listeners.push(callback))
		}, Node.prototype.off = function(eventName, callback) {
			var listeners, index = -1;
			eventName && "function" == typeof callback && (listeners = this.listeners[eventName]) && 0 <= (index = listeners.indexOf(callback)) && listeners.splice(index, 1)
		}, Node.prototype.emit = function(eventName) {
			var i, listeners = this.listeners[eventName];
			if (listeners && listeners.length)
				for (i = 0; i < listeners.length; i++) setTimeoutZero(listeners[i])
		}, Node.prototype.destroy = function() {
			var i, key;
			for (key in delete this.gl, delete this.seriously, this.listeners) this.listeners.hasOwnProperty(key) && delete this.listeners[key];
			for (i in this.uniforms) this.uniforms.hasOwnProperty(i) && delete this.uniforms[i];
			this.targets && delete this.targets, this.frameBuffer && this.frameBuffer.destroy && (this.frameBuffer.destroy(), delete this.frameBuffer), 0 <= (i = nodes.indexOf(this)) && nodes.splice(i, 1), delete nodesById[this.id], this.isDestroyed = !0
		}, Effect = function(effectNode) {
			var name, me = effectNode;

			function setInput(inputName, input) {
				var lookup, value, effectInput, name, element;
				return effectInput = me.effect.inputs[inputName], lookup = me.inputElements[inputName], "string" == typeof input && isNaN(input) && ("enum" === effectInput.type ? effectInput.options.hasOwnProperty(input) || (input = getElement(input, ["select"])) : "number" === effectInput.type || "boolean" === effectInput.type ? input = getElement(input, ["input", "select"]) : "image" === effectInput.type && (input = getElement(input, ["canvas", "img", "video"]))), isInstance(input, "HTMLInputElement") || isInstance(input, "HTMLSelectElement") ? (value = input.value, lookup && lookup.element !== input && (lookup.element.removeEventListener("change", lookup.listener, !0), lookup.element.removeEventListener("input", lookup.listener, !0), delete me.inputElements[inputName], lookup = null), lookup || (lookup = {
					element: input,
					listener: (name = inputName, element = input, function() {
						var oldValue, newValue;
						oldValue = "checkbox" === input.type ? input.checked : element.value, newValue = me.setInput(name, oldValue), "color" === effectInput.type && (newValue = colorArrayToHex(newValue).substr(0, 7)), newValue !== oldValue && (element.value = newValue)
					})
				}, me.inputElements[inputName] = lookup, "range" === input.type && input.addEventListener("input", lookup.listener, !0), input.addEventListener("change", lookup.listener, !0)), lookup && "checkbox" === input.type && (value = input.checked)) : (lookup && (lookup.element.removeEventListener("change", lookup.listener, !0), lookup.element.removeEventListener("input", lookup.listener, !0), delete me.inputElements[inputName]), value = input), me.setInput(inputName, value), me.inputs[inputName]
			}

			function makeImageSetter(inputName) {
				return function(value) {
					var val = setInput(inputName, value);
					return val && val.pub
				}
			}

			function makeImageGetter(inputName) {
				return function() {
					var val = me.inputs[inputName];
					return val && val.pub
				}
			}

			function makeSetter(inputName) {
				return function(value) {
					return setInput(inputName, value)
				}
			}

			function makeGetter(inputName) {
				return function() {
					return me.inputs[inputName]
				}
			}
			for (name in me.effect.inputs)
				if (me.effect.inputs.hasOwnProperty(name)) {
					if (void 0 !== this[name]) throw new Error("Cannot overwrite Seriously." + name);
					"image" === me.effect.inputs[name].type ? Object.defineProperty(this, name, {
						configurable: !0,
						enumerable: !0,
						get: makeImageGetter(name),
						set: makeImageSetter(name)
					}) : Object.defineProperty(this, name, {
						configurable: !0,
						enumerable: !0,
						get: makeGetter(name),
						set: makeSetter(name)
					})
				}
			Object.defineProperties(this, {
				effect: {
					enumerable: !0,
					configurable: !0,
					get: function() {
						return me.hook
					}
				},
				title: {
					enumerable: !0,
					configurable: !0,
					get: function() {
						return me.effect.title || me.hook
					}
				},
				width: {
					enumerable: !0,
					configurable: !0,
					get: function() {
						return me.width
					}
				},
				height: {
					enumerable: !0,
					configurable: !0,
					get: function() {
						return me.height
					}
				},
				id: {
					enumerable: !0,
					configurable: !0,
					get: function() {
						return me.id
					}
				}
			}), this.render = function() {
				return me.render(), this
			}, this.readPixels = function(x, y, width, height, dest) {
				return me.readPixels(x, y, width, height, dest)
			}, this.on = function(eventName, callback) {
				me.on(eventName, callback)
			}, this.off = function(eventName, callback) {
				me.off(eventName, callback)
			}, this.inputs = function(name) {
				var result, input, inputs, key;
				if (inputs = me.effect.inputs, name) return (input = inputs[name]) ? (result = {
					type: input.type,
					defaultValue: input.defaultValue,
					title: input.title || name
				}, "number" === input.type ? (result.min = input.min, result.max = input.max, result.step = input.step, result.mod = input.mod) : "enum" === input.type ? result.options = extend({}, input.options) : "vector" === input.type && (result.dimensions = input.dimensions), input.description && (result.description = input.description), result) : null;
				for (key in result = {}, inputs) inputs.hasOwnProperty(key) && (result[key] = this.inputs(key));
				return result
			}, this.alias = function(inputName, aliasName) {
				return me.alias(inputName, aliasName), this
			}, this.matte = function(polygons) {
				me.matte(polygons)
			}, this.destroy = function() {
				var i, descriptor;
				for (i in me.destroy(), this) this.hasOwnProperty(i) && "isDestroyed" !== i && "id" !== i && ((descriptor = Object.getOwnPropertyDescriptor(this, i)).get || descriptor.set || "function" != typeof this[i] ? delete this[i] : this[i] = nop)
			}, this.isDestroyed = function() {
				return me.isDestroyed
			}, this.isReady = function() {
				return me.ready
			}
		}, (EffectNode = function(hook, options) {
			var name, input, defaultValue, defaults, defaultSources = {};
			for (name in Node.call(this, options), this.gl = gl, this.effectRef = seriousEffects[hook], this.sources = {}, this.targets = [], this.inputElements = {}, this.dirty = !0, this.shaderDirty = !0, this.hook = hook, this.options = options, this.transform = null, this.effect = extend({}, this.effectRef), this.effectRef.definition && extend(this.effect, this.effectRef.definition.call(this, options)), validateInputSpecs(this.effect), this.uniforms.transform = identity, this.inputs = {}, defaults = defaultInputs[hook], this.effect.inputs) this.effect.inputs.hasOwnProperty(name) && (void 0 !== (input = this.effect.inputs[name]).defaultValue && null !== input.defaultValue || ("number" === input.type ? input.defaultValue = Math.min(Math.max(0, input.min), input.max) : "color" === input.type ? input.defaultValue = [0, 0, 0, 0] : "boolean" === input.type ? input.defaultValue = !1 : "string" === input.type ? input.defaultValue = "" : "enum" === input.type && (input.defaultValue = input.firstValue)), defaultValue = input.validate.call(this, input.defaultValue, input), defaults && void 0 !== defaults[name] && (defaultValue = input.validate.call(this, defaults[name], input, input.defaultValue, defaultValue), defaults[name] = defaultValue, "image" === input.type && (defaultSources[name] = defaultValue)), this.inputs[name] = defaultValue, input.uniform && (this.uniforms[input.uniform] = input.defaultValue));
			for (name in gl && (this.initialize(), this.effect.commonShader && this.buildShader()), this.updateReady(), this.inPlace = this.effect.inPlace, this.pub = new Effect(this), nodes.push(this), nodesById[this.id] = this, effects.push(this), allEffectsByHook[hook].push(this), defaultSources) defaultSources.hasOwnProperty(name) && this.setInput(name, defaultSources[name])
		}).prototype = Object.create(Node.prototype), (EffectNode.prototype.constructor = EffectNode).prototype.initialize = function() {
			if (!this.initialized) {
				var that = this;
				this.baseShader = baseShader, this.shape ? this.model = makeGlModel(this.shape, this.gl) : this.model = rectangleModel, "function" == typeof this.effect.initialize ? this.effect.initialize.call(this, function() {
					that.initFrameBuffer(!0)
				}, gl) : this.initFrameBuffer(!0), this.frameBuffer && (this.texture = this.frameBuffer.texture), this.initialized = !0
			}
		}, EffectNode.prototype.resize = function() {
			var i;
			for (Node.prototype.resize.call(this), this.effect.resize && this.effect.resize.call(this), i = 0; i < this.targets.length; i++) this.targets[i].resize()
		}, EffectNode.prototype.updateReady = function() {
			var i, key, effect, method, ready = !0;
			for (key in (effect = this.effect).inputs)
				if (effect.inputs.hasOwnProperty(key) && "image" === this.effect.inputs[key].type && (!this.sources[key] || !this.sources[key].ready) && (!effect.requires || effect.requires.call(this, key, this.inputs))) {
					ready = !1;
					break
				}
			if (this.ready !== ready && (this.ready = ready, this.emit(ready ? "ready" : "unready"), method = ready ? "setReady" : "setUnready", this.targets))
				for (i = 0; i < this.targets.length; i++) this.targets[i][method]()
		}, EffectNode.prototype.setReady = EffectNode.prototype.updateReady, EffectNode.prototype.setUnready = EffectNode.prototype.updateReady, EffectNode.prototype.addTarget = function(target) {
			var i;
			for (i = 0; i < this.targets.length; i++)
				if (this.targets[i] === target) return;
			this.targets.push(target)
		}, EffectNode.prototype.removeTarget = function(target) {
			var i = this.targets && this.targets.indexOf(target);
			0 <= i && this.targets.splice(i, 1)
		}, EffectNode.prototype.removeSource = function(source) {
			var i, pub = source && source.pub;
			for (i in this.inputs) !this.inputs.hasOwnProperty(i) || this.inputs[i] !== source && this.inputs[i] !== pub || (this.inputs[i] = null);
			for (i in this.sources) !this.sources.hasOwnProperty(i) || this.sources[i] !== source && this.sources[i] !== pub || (this.sources[i] = null)
		}, EffectNode.prototype.buildShader = function() {
			var shader, effect = this.effect,
				me = this;

			function addShaderName(shaderSrc) {
				return shaderNameRegex.test(shaderSrc) ? shaderSrc : "#define SHADER_NAME seriously." + me.hook + "\n" + shaderSrc
			}
			this.shaderDirty && (effect.commonShader && commonShaders[this.hook] ? (this.shader || commonShaders[this.hook].count++, this.shader = commonShaders[this.hook].shader) : effect.shader ? (this.shader && !effect.commonShader && this.shader.destroy(), (shader = effect.shader.call(this, this.inputs, {
				vertex: baseVertexShader,
				fragment: baseFragmentShader
			}, Seriously.util)) instanceof ShaderProgram ? this.shader = shader : shader && shader.vertex && shader.fragment ? this.shader = new ShaderProgram(gl, addShaderName(shader.vertex), addShaderName(shader.fragment)) : this.shader = baseShader, effect.commonShader && (commonShaders[this.hook] = {
				count: 1,
				shader: this.shader
			})) : this.shader = baseShader, this.shaderDirty = !1)
		}, EffectNode.prototype.render = function() {
			var key, frameBuffer, inPlace, effect = this.effect,
				that = this;
			if (gl) {
				if (this.initialized || this.initialize(), this.shaderDirty && this.buildShader(), this.dirty && this.ready) {
					for (key in this.sources) !this.sources.hasOwnProperty(key) || effect.requires && !effect.requires.call(this, key, this.inputs) || (inPlace = "function" == typeof this.inPlace ? this.inPlace(key) : this.inPlace, this.sources[key].render(!inPlace));
					this.frameBuffer && (frameBuffer = this.frameBuffer.frameBuffer), "function" == typeof effect.draw ? (effect.draw.call(this, this.shader, this.model, this.uniforms, frameBuffer, function(shader, model, uniforms, frameBuffer, node, options) {
						draw(shader, model, uniforms, frameBuffer, node || that, options)
					}), this.emit("render")) : frameBuffer && (draw(this.shader, this.model, this.uniforms, frameBuffer, this), this.emit("render")), this.dirty = !1
				}
				return this.texture
			}
		}, EffectNode.prototype.setInput = function(name, value) {
			var input, uniform, sourceKeys, source, defaultValue, me = this;
			if (this.effect.inputs.hasOwnProperty(name)) {
				if ("image" === (input = this.effect.inputs[name]).type) {
					if (value) {
						if ((value = findInputNode(value)) !== this.sources[name]) {
							if (function() {
									var key, previousSource = me.sources[name];
									if (previousSource) {
										for (key in me.sources)
											if (key !== name && me.sources.hasOwnProperty(key) && me.sources[key] === previousSource) return;
										previousSource.removeTarget(me)
									}
								}(), traceSources(value, this)) throw new Error("Attempt to make cyclical connection.");
							(this.sources[name] = value).addTarget(this)
						}
					} else delete this.sources[name], value = !1;
					uniform = this.sources[name], sourceKeys = Object.keys(this.sources), !0 === this.inPlace && 1 === sourceKeys.length ? (source = this.sources[sourceKeys[0]], this.uniforms.transform = source && source.cumulativeMatrix || identity) : this.uniforms.transform = identity
				} else defaultValue = defaultInputs[this.hook] && void 0 !== defaultInputs[this.hook][name] ? defaultInputs[this.hook][name] : input.defaultValue, uniform = value = input.validate.call(this, value, input, defaultValue, this.inputs[name]);
				return this.inputs[name] === value && "color" !== input.type && "vector" !== input.type || (this.inputs[name] = value, input.uniform && (this.uniforms[input.uniform] = uniform), "image" === input.type ? (this.resize(), this.updateReady()) : input.updateSources && this.updateReady(), input.shaderDirty && (this.shaderDirty = !0), this.setDirty(), input.update && input.update.call(this, value)), value
			}
		}, EffectNode.prototype.alias = function(inputName, aliasName) {
			var that = this;
			if (0 <= reservedNames.indexOf(aliasName)) throw new Error("'" + aliasName + "' is a reserved name and cannot be used as an alias.");
			return this.effect.inputs.hasOwnProperty(inputName) && (aliasName || (aliasName = inputName), seriously.removeAlias(aliasName), aliases[aliasName] = {
				node: this,
				input: inputName
			}, Object.defineProperty(seriously, aliasName, {
				configurable: !0,
				enumerable: !0,
				get: function() {
					return that.inputs[inputName]
				},
				set: function(value) {
					return that.setInput(inputName, value)
				}
			})), this
		}, EffectNode.prototype.matte = function(poly) {
			var polys, polygon, i, j, v, vert, prev, polygons = [],
				vertices = [],
				shape = {};

			function makeSimple(poly) {
				var i, j, edge1, edge2, intersect, newPoly, head, point, newPolygons, point1, point2, intersections = [];
				if (!poly.simple) {
					for (i = 0; i < poly.edges.length; i++)
						for (edge1 = poly.edges[i], j = i + 1; j < poly.edges.length; j++) edge2 = poly.edges[j], a1 = edge1[0], a2 = edge1[1], b1 = edge2[0], b2 = edge2[1], ub = ua = u_b = ub_t = ua_t = void 0, ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x), ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x), (intersect = !!((u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y)) && (ub = ub_t / u_b, 0 < (ua = ua_t / u_b) && ua <= 1 && 0 < ub && ub <= 1)) && {
							x: a1.x + ua * (a2.x - a1.x),
							y: a1.y + ua * (a2.y - a1.y)
						}) && (intersect.edge1 = edge1, intersect.edge2 = edge2, intersections.push(intersect));
					var a1, a2, b1, b2, ua_t, ub_t, u_b, ua, ub;
					if (intersections.length) {
						for (newPolygons = [], i = 0; i < intersections.length; i++) edge1 = (intersect = intersections[i]).edge1, edge2 = intersect.edge2, point1 = {
							x: intersect.x,
							y: intersect.y,
							prev: edge1[0],
							next: edge2[1],
							id: vertices.length
						}, poly.vertices.push(point1), vertices.push(point1), point2 = {
							x: intersect.x,
							y: intersect.y,
							prev: edge2[0],
							next: edge1[1],
							id: vertices.length
						}, poly.vertices.push(point2), vertices.push(point1), (point1.prev.next = point1).next.prev = point1, (point2.prev.next = point2).next.prev = point2;
						do {
							for (newPoly = {
									edges: [],
									vertices: [],
									simple: !0
								}, newPolygons.push(newPoly), head = point = poly.vertices[0]; i = poly.vertices.indexOf(point), poly.vertices.splice(i, 1), newPoly.edges.push([point, point.next]), newPoly.vertices.push(point), (point = point.next) !== head;);
						} while (poly.vertices.length);
						for (i = polygons.indexOf(poly), polygons.splice(i, 1), i = 0; i < newPolygons.length; i++) polygons.push(newPolygons[i])
					} else poly.simple = !0
				}
			}

			function clockWise(poly) {
				var p, q, pv, qv, n = poly.vertices.length,
					sum = 0;
				for (p = n - 1, q = 0; q < n; p = q, q++) pv = poly.vertices[p], qv = poly.vertices[q], sum += pv.x * qv.y - qv.x * pv.y;
				return 0 < sum
			}

			function triangulate(poly) {
				var v, n, nv, count, u, w, a, b, c, s, t, points = poly.vertices,
					V = [],
					indices = [];

				function pointInTriangle(a, b, c, p) {
					var ax, ay, bx, by, cx, cy, apx, apy, bpx, bpy, cpx, cpy;
					return ax = c.x - b.x, ay = c.y - b.y, bx = a.x - c.x, by = a.y - c.y, cx = b.x - a.x, cy = b.y - a.y, apx = p.x - a.x, apy = p.y - a.y, bpx = p.x - b.x, bpy = p.y - b.y, cpx = p.x - c.x, cpy = p.y - c.y, 0 <= ax * bpy - ay * bpx && 0 <= bx * cpy - by * cpx && 0 <= cx * apy - cy * apx
				}

				function snip(u, v, w, n, V) {
					var p, a, b, c;
					if (a = points[V[u]], b = points[V[v]], c = points[V[w]], (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x) < 0) return !1;
					for (p = 0; p < n; p++)
						if (p !== u && p !== v && p !== w && pointInTriangle(a, b, c, points[V[p]])) return !1;
					return !0
				}
				if (n = points.length, poly.clockWise)
					for (v = 0; v < n; v++) V[v] = v;
				else
					for (v = 0; v < n; v++) V[v] = n - 1 - v;
				for (count = 2 * (nv = n), 0, v = nv - 1; 2 < nv;) {
					if (count-- <= 0) return indices;
					if (nv <= (u = v) && (u = 0), nv <= (v = u + 1) && (v = 0), nv < (w = v + 1) && (w = 0), snip(u, v, w, nv, V)) {
						for (a = V[u], b = V[v], c = V[w], poly.clockWise ? (indices.push(points[a]), indices.push(points[b]), indices.push(points[c])) : (indices.push(points[c]), indices.push(points[b]), indices.push(points[a])), 0, t = (s = v) + 1; t < nv; s++, t++) V[s] = V[t];
						count = 2 * --nv
					}
				}
				polygon.indices = indices
			}
			for (polys = function(poly) {
					return poly && poly.length && Array.isArray(poly) ? Array.isArray(poly[0]) ? Array.isArray(poly[0]) && !isNaN(poly[0][0]) ? [poly] : poly : [poly] : []
				}(poly), i = 0; i < polys.length; i++) {
				for (poly = polys[i], prev = null, polygon = {
						vertices: [],
						edges: []
					}, j = 0; j < poly.length; j++) "object" != typeof(v = poly[j]) || isNaN(v.x) || isNaN(v.y) ? 2 <= v.length && !isNaN(v[0]) && !isNaN(v[1]) && (vert = {
					x: v[0],
					y: v[1],
					id: vertices.length
				}) : vert = {
					x: v.x,
					y: v.y,
					id: vertices.length
				}, vert && (prev ? ((prev.next = vert).prev = prev, vert.next = polygon.vertices[0], polygon.vertices[0].prev = vert) : ((polygon.head = vert).next = vert).prev = vert, vertices.push(vert), polygon.vertices.push(vert), prev = vert);
				if (2 < polygon.vertices.length)
					for (3 === polygon.vertices.length && (polygon.simple = !0), polygons.push(polygon), j = 0; j < polygon.vertices.length; j++) vert = polygon.vertices[j], polygon.edges.push([vert, vert.next])
			}
			for (i = polygons.length - 1; 0 <= i; i--) makeSimple(polygon = polygons[i]);
			for (i = 0; i < polygons.length; i++)(polygon = polygons[i]).clockWise = clockWise(polygon), triangulate(polygon);
			for (shape.vertices = [], shape.coords = [], i = 0; i < vertices.length; i++) v = vertices[i], shape.vertices.push(2 * v.x - 1), shape.vertices.push(-2 * v.y + 1), shape.vertices.push(-1), shape.coords.push(v.x), shape.coords.push(-1 * v.y + 1);
			for (shape.vertices = new Float32Array(shape.vertices), shape.coords = new Float32Array(shape.coords), shape.indices = [], i = 0; i < polygons.length; i++)
				for (polygon = polygons[i], j = 0; j < polygon.indices.length; j++) v = polygon.indices[j], shape.indices.push(v.id);
			shape.indices = new Uint16Array(shape.indices), this.shape = shape, this.gl && makeGlModel(shape, this.gl)
		}, EffectNode.prototype.destroy = function() {
			var i, key, item, hook = this.hook;
			for (key in this.effect.destroy && "function" == typeof this.effect.destroy && this.effect.destroy.call(this), delete this.effect, commonShaders[hook] && (commonShaders[hook].count--, commonShaders[hook].count || delete commonShaders[hook]), this.shader && this.shader.destroy && this.shader !== baseShader && !commonShaders[hook] && this.shader.destroy(), delete this.shader, this.inputElements) this.inputElements.hasOwnProperty(key) && ((item = this.inputElements[key]).element.removeEventListener("change", item.listener, !0), item.element.removeEventListener("input", item.listener, !0));
			for (key in this.sources) this.sources.hasOwnProperty(key) && ((item = this.sources[key]) && item.removeTarget && item.removeTarget(this), delete this.sources[key]);
			for (; this.targets.length;)(item = this.targets.pop()) && item.removeSource && item.removeSource(this);
			for (key in this) this.hasOwnProperty(key) && "id" !== key && delete this[key];
			for (key in aliases) aliases.hasOwnProperty(key) && (item = aliases[key]).node === this && seriously.removeAlias(key);
			0 <= (i = effects.indexOf(this)) && effects.splice(i, 1), 0 <= (i = allEffectsByHook[hook].indexOf(this)) && allEffectsByHook[hook].splice(i, 1), Node.prototype.destroy.call(this)
		}, Source = function(sourceNode) {
			var me = sourceNode;
			Object.defineProperties(this, {
				original: {
					enumerable: !0,
					configurable: !0,
					get: function() {
						return me.source
					}
				},
				id: {
					enumerable: !0,
					configurable: !0,
					get: function() {
						return me.id
					}
				},
				width: {
					enumerable: !0,
					configurable: !0,
					get: function() {
						return me.width
					}
				},
				height: {
					enumerable: !0,
					configurable: !0,
					get: function() {
						return me.height
					}
				}
			}), this.render = function() {
				me.render()
			}, this.update = function() {
				me.setDirty()
			}, this.readPixels = function(x, y, width, height, dest) {
				return me.readPixels(x, y, width, height, dest)
			}, this.on = function(eventName, callback) {
				me.on(eventName, callback)
			}, this.off = function(eventName, callback) {
				me.off(eventName, callback)
			}, this.destroy = function() {
				var i, descriptor;
				for (i in me.destroy(), this) this.hasOwnProperty(i) && "isDestroyed" !== i && "id" !== i && ((descriptor = Object.getOwnPropertyDescriptor(this, i)).get || descriptor.set || "function" != typeof this[i] ? delete this[i] : this[i] = nop)
			}, this.isDestroyed = function() {
				return me.isDestroyed
			}, this.isReady = function() {
				return me.ready
			}
		}, (SourceNode = function(hook, source, options) {
			var key, plugin, opts = options || {},
				flip = void 0 === opts.flip || opts.flip,
				width = opts.width,
				height = opts.height,
				deferTexture = !1,
				that = this,
				matchedType = !1;

			function sourcePlugin(hook, source, options, force) {
				var p = seriousSources[hook];
				if (p.definition) {
					if (!(p = p.definition.call(that, source, options, force))) return null;
					p = extend(extend({}, seriousSources[hook]), p)
				}
				return p
			}

			function compareSource(source) {
				return that.source === source
			}
			if (Node.call(this), (hook && "string" != typeof hook || !source && 0 !== source) && (options && "object" == typeof options || (options = source), source = hook), "string" == typeof source && isNaN(source) && (source = getElement(source, ["canvas", "img", "video"])), "string" == typeof hook && seriousSources[hook] && (plugin = sourcePlugin(hook, source, options, !0)) && (this.hook = hook, matchedType = !0, deferTexture = plugin.deferTexture, this.plugin = plugin, this.compare = plugin.compare, this.checkDirty = plugin.checkDirty, plugin.source && (source = plugin.source)), !plugin && isInstance(source)) "CANVAS" === source.tagName ? (this.width = source.width, this.height = source.height, this.render = this.renderImageCanvas, matchedType = !0, this.hook = "canvas", this.compare = compareSource) : "IMG" === source.tagName && (this.width = source.naturalWidth || 1, this.height = source.naturalHeight || 1, source.complete && source.naturalWidth || (deferTexture = !0), source.addEventListener("load", function() {
				that.isDestroyed || (that.width === source.naturalWidth && that.height === source.naturalHeight || (that.width = source.naturalWidth, that.height = source.naturalHeight, that.resize()), that.setDirty(), that.setReady())
			}, !0), this.render = this.renderImageCanvas, matchedType = !0, this.hook = "image", this.compare = compareSource);
			else if (!plugin && isInstance(source, "WebGLTexture")) {
				if (gl && !gl.isTexture(source)) throw new Error("Not a valid WebGL texture.");
				isNaN(width) ? isNaN(height) || (width = height) : isNaN(height) && (height = width), this.width = width, this.height = height, void 0 === opts.flip && (flip = !1), matchedType = !0, this.texture = source, this.initialized = !0, this.hook = "texture", this.compare = compareSource, this.render = function() {}
			}
			if (!matchedType && !plugin)
				for (key in seriousSources)
					if (seriousSources.hasOwnProperty(key) && seriousSources[key] && (plugin = sourcePlugin(key, source, options, !1))) {
						this.hook = key, matchedType = !0, deferTexture = plugin.deferTexture, this.plugin = plugin, this.compare = plugin.compare, this.checkDirty = plugin.checkDirty, plugin.source && (source = plugin.source);
						break
					}
			if (!matchedType) throw new Error("Unknown source type");
			this.source = source, void 0 === this.flip && (this.flip = flip), this.targets = [], deferTexture || that.setReady(), this.pub = new Source(this), nodes.push(this), nodesById[this.id] = this, sources.push(this), allSourcesByHook[this.hook].push(this), sources.length && !rafId && renderDaemon()
		}).prototype = Object.create(Node.prototype), (SourceNode.prototype.constructor = SourceNode).prototype.initialize = function() {
			var texture;
			gl && !this.texture && this.ready && (texture = gl.createTexture(), gl.bindTexture(gl.TEXTURE_2D, texture), gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE), gl.bindTexture(gl.TEXTURE_2D, null), this.texture = texture, this.initialized = !0, this.allowRefresh = !0, this.setDirty())
		}, SourceNode.prototype.initFrameBuffer = function(useFloat) {
			gl && (this.frameBuffer = new FrameBuffer(gl, this.width, this.height, {
				texture: this.texture,
				useFloat: useFloat
			}))
		}, SourceNode.prototype.addTarget = function(target) {
			var i;
			for (i = 0; i < this.targets.length; i++)
				if (this.targets[i] === target) return;
			this.targets.push(target)
		}, SourceNode.prototype.removeTarget = function(target) {
			var i = this.targets && this.targets.indexOf(target);
			0 <= i && this.targets.splice(i, 1)
		}, SourceNode.prototype.resize = function() {
			var i, target;
			if (this.uniforms.resolution[0] = this.width, this.uniforms.resolution[1] = this.height, this.framebuffer && this.framebuffer.resize(this.width, this.height), this.emit("resize"), this.setDirty(), this.targets)
				for (i = 0; i < this.targets.length; i++)(target = this.targets[i]).resize(), target.setTransformDirty && target.setTransformDirty()
		}, SourceNode.prototype.setReady = function() {
			var i;
			if (!this.ready && (this.ready = !0, this.resize(), this.initialize(), this.emit("ready"), this.targets))
				for (i = 0; i < this.targets.length; i++) this.targets[i].setReady()
		}, SourceNode.prototype.render = function() {
			var media = this.source;
			gl && (media || 0 === media) && this.ready && (this.initialized || this.initialize(), this.allowRefresh && this.plugin && this.plugin.render && (this.dirty || this.checkDirty && this.checkDirty()) && this.plugin.render.call(this, gl, draw, rectangleModel, baseShader) && (this.dirty = !1, this.emit("render")))
		}, SourceNode.prototype.renderImageCanvas = function() {
			var media = this.source;
			if (gl && media && this.ready && (this.initialized || this.initialize(), this.allowRefresh && this.dirty)) {
				gl.bindTexture(gl.TEXTURE_2D, this.texture), gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.flip), gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1);
				try {
					return gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, media), this.dirty = !1, this.emit("render"), !0
				} catch (securityError) {
					securityError.code === window.DOMException.SECURITY_ERR && (this.allowRefresh = !1, Seriously.logger.error("Unable to access cross-domain image"))
				}
				return !1
			}
		}, SourceNode.prototype.destroy = function() {
			var i, key, item;
			for (this.plugin && this.plugin.destroy && this.plugin.destroy.call(this), gl && this.texture && gl.deleteTexture(this.texture); this.targets.length;)(item = this.targets.pop()) && item.removeSource && item.removeSource(this);
			for (key in 0 <= (i = sources.indexOf(this)) && sources.splice(i, 1), 0 <= (i = allSourcesByHook[this.hook].indexOf(this)) && allSourcesByHook[this.hook].splice(i, 1), this) this.hasOwnProperty(key) && "id" !== key && delete this[key];
			Node.prototype.destroy.call(this)
		}, Target = function(targetNode) {
			var me = targetNode;
			Object.defineProperties(this, {
				source: {
					enumerable: !0,
					configurable: !0,
					get: function() {
						if (me.source) return me.source.pub
					},
					set: function(value) {
						me.setSource(value)
					}
				},
				original: {
					enumerable: !0,
					configurable: !0,
					get: function() {
						return me.target
					}
				},
				width: {
					enumerable: !0,
					configurable: !0,
					get: function() {
						return me.width
					},
					set: function(value) {
						!isNaN(value) && 0 < value && me.width !== value && (me.width = value, me.resize(), me.setTransformDirty())
					}
				},
				height: {
					enumerable: !0,
					configurable: !0,
					get: function() {
						return me.height
					},
					set: function(value) {
						!isNaN(value) && 0 < value && me.height !== value && (me.height = value, me.resize(), me.setTransformDirty())
					}
				},
				id: {
					enumerable: !0,
					configurable: !0,
					get: function() {
						return me.id
					}
				}
			}), this.render = function() {
				me.render()
			}, this.readPixels = function(x, y, width, height, dest) {
				return me.readPixels(x, y, width, height, dest)
			}, this.on = function(eventName, callback) {
				me.on(eventName, callback)
			}, this.off = function(eventName, callback) {
				me.off(eventName, callback)
			}, this.go = function(options) {
				me.go(options)
			}, this.stop = function() {
				me.stop()
			}, this.getTexture = function() {
				return me.frameBuffer.texture
			}, this.destroy = function() {
				var i, descriptor;
				for (i in me.destroy(), this) this.hasOwnProperty(i) && "isDestroyed" !== i && "id" !== i && ((descriptor = Object.getOwnPropertyDescriptor(this, i)).get || descriptor.set || "function" != typeof this[i] ? delete this[i] : this[i] = nop)
			}, this.inputs = function(name) {
				return {
					source: {
						type: "image"
					}
				}
			}, this.isDestroyed = function() {
				return me.isDestroyed
			}, this.isReady = function() {
				return me.ready
			}
		}, (((TargetNode = function(hook, target, options) {
			var opts, flip, width, height, context, debugContext, frameBuffer, targetList, key, that = this,
				matchedType = !1;

			function targetPlugin(hook, target, options, force) {
				var plugin = seriousTargets[hook];
				if (plugin.definition) {
					if (!(plugin = plugin.definition.call(that, target, options, force))) return null;
					plugin = extend(extend({}, seriousTargets[hook]), plugin), that.hook = key, matchedType = !0, that.plugin = plugin, that.compare = plugin.compare, plugin.target && (target = plugin.target), plugin.gl && !that.gl && (that.gl = plugin.gl, gl || attachContext(plugin.gl)), that.gl === gl && (that.model = rectangleModel, that.shader = baseShader)
				}
				return plugin
			}
			if (Node.call(this), (hook && "string" != typeof hook || !target && 0 !== target) && (options && "object" == typeof options || (options = target), target = hook), flip = void 0 === (opts = options || {}).flip || opts.flip, width = parseInt(opts.width, 10), height = parseInt(opts.height, 10), debugContext = opts.debugContext, "string" == typeof hook && seriousTargets[hook] && targetPlugin(hook, target, opts, !0), this.renderToTexture = opts.renderToTexture, isInstance(target, "WebGLFramebuffer"))
				if (frameBuffer = target, isInstance(opts, "HTMLCanvasElement")) target = opts;
				else if (isInstance(opts, "WebGLRenderingContext")) target = opts.canvas;
			else if (isInstance(opts.canvas, "HTMLCanvasElement")) target = opts.canvas;
			else {
				if (!isInstance(opts.context, "WebGLRenderingContext")) throw new Error("Must provide a canvas with WebGLFramebuffer target");
				target = opts.context.canvas
			}
			if (isInstance(target, "HTMLCanvasElement")) {
				if (width = target.width, height = target.height, (!gl || gl.canvas !== target && opts.allowSecondaryWebGL) && (context = getWebGlContext(target, {
						alpha: !0,
						premultipliedAlpha: !0,
						preserveDrawingBuffer: !0,
						stencil: !0,
						debugContext: debugContext
					})), context) gl && gl !== context ? (this.gl = context, this.frameBuffer = {
					frameBuffer: frameBuffer || null
				}, this.shader = new ShaderProgram(this.gl, baseVertexShader, baseFragmentShader), this.model = buildRectangleModel.call(this, this.gl), this.pixels = null, this.texture = this.gl.createTexture(), this.gl.bindTexture(gl.TEXTURE_2D, this.texture), this.gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR), this.gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR), this.gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), this.gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE), this.render = this.renderSecondaryWebGL) : (primaryTarget || (primaryTarget = this), gl || attachContext(context), this.render = this.renderWebGL, opts.renderToTexture ? gl && (this.frameBuffer = new FrameBuffer(gl, width, height, !1)) : this.frameBuffer = {
					frameBuffer: frameBuffer || null
				});
				else {
					if (!opts.allowSecondaryWebGL && gl && gl.canvas !== target) throw new Error("Only one WebGL target canvas allowed. Set allowSecondaryWebGL option to create secondary context.");
					this.render = nop, Seriously.logger.log("Unable to create WebGL context.")
				}
				matchedType = !0
			}
			if (!matchedType)
				for (key in seriousTargets)
					if (seriousTargets.hasOwnProperty(key) && seriousTargets[key] && targetPlugin(key, target, opts, !1)) break;
			if (!matchedType) throw new Error("Unknown target type");
			allTargets && ((targetList = allTargets.get(target)) ? Seriously.logger.warn("Target already in use by another instance", target, Object.keys(targetList).map(function(key) {
				return targetList[key]
			})) : (targetList = {}, allTargets.set(target, targetList)), targetList[seriously.id] = seriously), this.target = target, this.transform = null, this.transformDirty = !0, this.flip = flip, width && (this.width = width), height && (this.height = height), this.uniforms.resolution[0] = this.width, this.uniforms.resolution[1] = this.height, void 0 !== opts.auto ? this.auto = opts.auto : this.auto = auto, this.frames = 0, this.pub = new Target(this), nodes.push(this), nodesById[this.id] = this, targets.push(this)
		}).prototype = Object.create(Node.prototype)).constructor = TargetNode).prototype.setSource = function(source) {
			var newSource;
			(newSource = findInputNode(source)) !== this.source && (this.source && this.source.removeTarget(this), (this.source = newSource).addTarget(this), newSource && (this.resize(), newSource.ready ? this.setReady() : this.setUnready()), this.setDirty())
		}, TargetNode.prototype.setDirty = function() {
			this.dirty = !0, this.auto && !rafId && (rafId = requestAnimationFrame(renderDaemon))
		}, TargetNode.prototype.resize = function() {
			isInstance(this.target, "HTMLCanvasElement") ? this.width === this.target.width && this.height === this.target.height || (this.target.width = this.width, this.target.height = this.height, this.uniforms.resolution[0] = this.width, this.uniforms.resolution[1] = this.height, this.emit("resize"), this.setTransformDirty()) : this.plugin && this.plugin.resize && this.plugin.resize.call(this), !this.source || this.source.width === this.width && this.source.height === this.height || this.transform || (this.transform = new Float32Array(16))
		}, TargetNode.prototype.setTransformDirty = function() {
			this.transformDirty = !0, this.setDirty()
		}, TargetNode.prototype.go = function() {
			this.auto = !0, this.setDirty()
		}, TargetNode.prototype.stop = function() {
			this.auto = !1
		}, TargetNode.prototype.render = function() {
			gl && this.plugin && this.plugin.render && this.plugin.render.call(this, draw, baseShader, rectangleModel)
		}, TargetNode.prototype.renderWebGL = function() {
			var matrix, x, y;
			if (this.resize(), gl && this.dirty && this.ready) {
				if (!this.source) return;
				this.source.render(), this.uniforms.source = this.source.texture, this.source.width === this.width && this.source.height === this.height ? this.uniforms.transform = this.source.cumulativeMatrix || identity : this.transformDirty && (matrix = this.transform, mat4.copy(matrix, this.source.cumulativeMatrix || identity), x = this.source.width / this.width, y = this.source.height / this.height, matrix[0] *= x, matrix[1] *= x, matrix[2] *= x, matrix[3] *= x, matrix[4] *= y, matrix[5] *= y, matrix[6] *= y, matrix[7] *= y, this.uniforms.transform = matrix, this.transformDirty = !1), draw(baseShader, rectangleModel, this.uniforms, this.frameBuffer.frameBuffer, this, outputRenderOptions), this.emit("render"), this.dirty = !1
			}
		}, TargetNode.prototype.renderSecondaryWebGL = function() {
			var sourceWidth, sourceHeight, matrix, x, y;
			this.dirty && this.ready && this.source && (this.emit("render"), this.source.render(!0), sourceWidth = this.source.width, sourceHeight = this.source.height, this.pixels && this.pixels.length === sourceWidth * sourceHeight * 4 || (this.pixels = new Uint8Array(sourceWidth * sourceHeight * 4)), this.source.readPixels(0, 0, sourceWidth, sourceHeight, this.pixels), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, sourceWidth, sourceHeight, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.pixels), sourceWidth === this.width && sourceHeight === this.height ? this.uniforms.transform = identity : this.transformDirty && (matrix = this.transform, mat4.copy(matrix, identity), x = this.source.width / this.width, y = this.source.height / this.height, matrix[0] *= x, matrix[1] *= x, matrix[2] *= x, matrix[3] *= x, matrix[4] *= y, matrix[5] *= y, matrix[6] *= y, matrix[7] *= y, this.uniforms.transform = matrix, this.transformDirty = !1), this.uniforms.source = this.texture, draw(this.shader, this.model, this.uniforms, null, this, outputRenderOptions), this.dirty = !1)
		}, TargetNode.prototype.removeSource = function(source) {
			this.source !== source && this.source !== source.pub || (this.source = null)
		}, TargetNode.prototype.destroy = function() {
			var i, targetList;
			this.source && this.source.removeTarget && this.source.removeTarget(this), allTargets && (delete(targetList = allTargets.get(this.target))[seriously.id], Object.keys(targetList).length || allTargets.delete(this.target)), this.plugin && this.plugin.destroy && this.plugin.destroy.call(this), delete this.source, delete this.target, delete this.pub, delete this.uniforms, delete this.pixels, delete this.auto, 0 <= (i = targets.indexOf(this)) && targets.splice(i, 1), Node.prototype.destroy.call(this), this === primaryTarget && (glCanvas.removeEventListener("webglcontextrestored", restoreContext, !1), destroyContext(), primaryTarget = null)
		}, Transform = function(transformNode) {
			var key, me = transformNode,
				self = this;

			function setProperty(name, def) {
				Object.defineProperty(self, name, {
					configurable: !0,
					enumerable: !0,
					get: function() {
						return def.get.call(me)
					},
					set: function(val) {
						! function(inputName, def, input) {
							var lookup, value, element;
							lookup = me.inputElements[inputName], "string" == typeof input && isNaN(input) && ("enum" === def.type ? def.options.hasOwnProperty(input) || (input = getElement(input, ["select"])) : "number" === def.type || "boolean" === def.type ? input = getElement(input, ["input", "select"]) : "image" === def.type && (input = getElement(input, ["canvas", "img", "video"]))), isInstance(input, "HTMLInputElement") || isInstance(input, "HTMLSelectElement") ? (value = input.value, lookup && lookup.element !== input && (lookup.element.removeEventListener("change", lookup.listener, !0), lookup.element.removeEventListener("input", lookup.listener, !0), delete me.inputElements[inputName], lookup = null), lookup || (lookup = {
								element: input,
								listener: (element = input, function() {
									var oldValue, newValue;
									oldValue = "checkbox" === input.type ? input.checked : element.value, newValue = me.setInput(inputName, oldValue), "color" === input.type && (newValue = colorArrayToHex(newValue)), newValue !== oldValue && (element.value = newValue)
								})
							}, me.inputElements[inputName] = lookup, "range" === input.type && input.addEventListener("input", lookup.listener, !0), input.addEventListener("change", lookup.listener, !0)), lookup && "checkbox" === input.type && (value = input.checked)) : (lookup && (lookup.element.removeEventListener("change", lookup.listener, !0), lookup.element.removeEventListener("input", lookup.listener, !0), delete me.inputElements[inputName]), value = input), me.setInput(inputName, value)
						}(name, def, val)
					}
				})
			}

			function makeMethod(method) {
				return function() {
					method.apply(me, arguments) && me.setTransformDirty()
				}
			}
			for (key in Object.defineProperties(this, {
					transform: {
						enumerable: !0,
						configurable: !0,
						get: function() {
							return me.hook
						}
					},
					title: {
						enumerable: !0,
						configurable: !0,
						get: function() {
							return me.plugin.title || me.hook
						}
					},
					width: {
						enumerable: !0,
						configurable: !0,
						get: function() {
							return me.width
						}
					},
					height: {
						enumerable: !0,
						configurable: !0,
						get: function() {
							return me.height
						}
					},
					id: {
						enumerable: !0,
						configurable: !0,
						get: function() {
							return me.id
						}
					},
					source: {
						enumerable: !0,
						configurable: !0,
						get: function() {
							return me.source && me.source.pub
						},
						set: function(source) {
							me.setSource(source)
						}
					}
				}), me.methods) me.methods.hasOwnProperty(key) && (this[key] = makeMethod(me.methods[key]));
			for (key in me.inputs) me.inputs.hasOwnProperty(key) && setProperty(key, me.inputs[key]);
			this.update = function() {
				me.setDirty()
			}, this.inputs = function(name) {
				var result, input, inputs, key;
				if (inputs = me.plugin.inputs, name) return !(input = inputs[name]) || input.method ? null : (result = {
					type: input.type,
					defaultValue: input.defaultValue,
					title: input.title || name
				}, "number" === input.type ? (result.min = input.min, result.max = input.max, result.step = input.step, result.mod = input.mod) : "enum" === input.type ? result.options = extend({}, input.options) : "vector" === input.type && (result.dimensions = input.dimensions), input.description && (result.description = input.description), result);
				for (key in result = {}, inputs) inputs.hasOwnProperty(key) && !inputs[key].method && (result[key] = this.inputs(key));
				return result
			}, this.alias = function(inputName, aliasName) {
				return me.alias(inputName, aliasName), this
			}, this.on = function(eventName, callback) {
				me.on(eventName, callback)
			}, this.off = function(eventName, callback) {
				me.off(eventName, callback)
			}, this.destroy = function() {
				var i, descriptor;
				for (i in me.destroy(), this) this.hasOwnProperty(i) && "isDestroyed" !== i && "id" !== i && ((descriptor = Object.getOwnPropertyDescriptor(this, i)).get || descriptor.set || "function" != typeof this[i] ? delete this[i] : this[i] = nop)
			}, this.isDestroyed = function() {
				return me.isDestroyed
			}, this.isReady = function() {
				return me.ready
			}
		}, (TransformNode = function(hook, options) {
			var key, input, initialValue, defaultValue, defaults;
			for (key in this.matrix = new Float32Array(16), this.cumulativeMatrix = new Float32Array(16), this.ready = !1, this.width = 1, this.height = 1, this.seriously = seriously, this.transformRef = seriousTransforms[hook], this.hook = hook, this.id = nodeId, nodeId++, this.options = options, this.sources = null, this.targets = [], this.inputElements = {}, this.inputs = {}, this.methods = {}, this.listeners = {}, this.texture = null, this.frameBuffer = null, this.uniforms = null, this.dirty = !0, this.transformDirty = !0, this.renderDirty = !1, this.isDestroyed = !1, this.transformed = !1, this.plugin = extend({}, this.transformRef), this.transformRef.definition && extend(this.plugin, this.transformRef.definition.call(this, options)), this.plugin.inputs) this.plugin.inputs.hasOwnProperty(key) && ((input = this.plugin.inputs[key]).method && "function" == typeof input.method ? this.methods[key] = input.method : "function" == typeof input.set && "function" == typeof input.get && (this.inputs[key] = input));
			for (key in validateInputSpecs(this.plugin), defaults = defaultInputs[hook], this.plugin.inputs) this.plugin.inputs.hasOwnProperty(key) && "function" == typeof(input = this.plugin.inputs[key]).set && "function" == typeof input.get && "function" != typeof input.method && (initialValue = input.get.call(this), defaultValue = void 0 === input.defaultValue ? initialValue : input.defaultValue, defaultValue = input.validate.call(this, defaultValue, input, initialValue), defaults && void 0 !== defaults[key] && (defaultValue = input.validate.call(this, defaults[key], input, input.defaultValue, defaultValue), defaults[key] = defaultValue), defaultValue !== initialValue && input.set.call(this, defaultValue));
			nodes.push(this), (nodesById[this.id] = this).pub = new Transform(this), transforms.push(this), allTransformsByHook[hook].push(this)
		}).prototype = Object.create(Node.prototype), (TransformNode.prototype.constructor = TransformNode).prototype.setDirty = function() {
			this.renderDirty = !0, Node.prototype.setDirty.call(this)
		}, TransformNode.prototype.setTransformDirty = function() {
			var i, target;
			for (this.transformDirty = !0, this.dirty = !0, this.renderDirty = !0, i = 0; i < this.targets.length; i++)(target = this.targets[i]).setTransformDirty ? target.setTransformDirty() : target.setDirty()
		}, TransformNode.prototype.resize = function() {
			var i;
			for (Node.prototype.resize.call(this), this.plugin.resize && this.plugin.resize.call(this), i = 0; i < this.targets.length; i++) this.targets[i].resize();
			this.setTransformDirty()
		}, TransformNode.prototype.setSource = function(source) {
			var newSource;
			if ((newSource = findInputNode(source)) !== this.source) {
				if (traceSources(newSource, this)) throw new Error("Attempt to make cyclical connection.");
				this.source && this.source.removeTarget(this), (this.source = newSource).addTarget(this), newSource && newSource.ready ? this.setReady() : this.setUnready(), this.resize()
			}
		}, TransformNode.prototype.addTarget = function(target) {
			var i;
			for (i = 0; i < this.targets.length; i++)
				if (this.targets[i] === target) return;
			this.targets.push(target)
		}, TransformNode.prototype.removeTarget = function(target) {
			var i = this.targets && this.targets.indexOf(target);
			0 <= i && this.targets.splice(i, 1), this.targets && this.targets.length && this.resize()
		}, TransformNode.prototype.setInput = function(name, value) {
			var input, defaultValue, previous;
			if (this.plugin.inputs.hasOwnProperty(name)) return input = this.plugin.inputs[name], defaultValue = defaultInputs[this.hook] && void 0 !== defaultInputs[this.hook][name] ? defaultInputs[this.hook][name] : input.defaultValue, previous = input.get.call(this), void 0 === defaultValue && (defaultValue = previous), value = input.validate.call(this, value, input, defaultValue, previous), input.set.call(this, value) && this.setTransformDirty(), input.get.call(this)
		}, TransformNode.prototype.alias = function(inputName, aliasName) {
			var input, def, me = this;
			if (0 <= reservedNames.indexOf(aliasName)) throw new Error("'" + aliasName + "' is a reserved name and cannot be used as an alias.");
			return this.plugin.inputs.hasOwnProperty(inputName) && (aliasName || (aliasName = inputName), seriously.removeAlias(aliasName), (input = this.inputs[inputName]) ? (def = me.inputs[inputName], Object.defineProperty(seriously, aliasName, {
				configurable: !0,
				enumerable: !0,
				get: function() {
					return def.get.call(me)
				},
				set: function(val) {
					def.set.call(me, val) && me.setTransformDirty()
				}
			})) : (input = this.methods[inputName]) && (def = input, seriously[aliasName] = function() {
				def.apply(me, arguments) && me.setTransformDirty()
			}), input && (aliases[aliasName] = {
				node: this,
				input: inputName
			})), this
		}, TransformNode.prototype.render = function(renderTransform) {
			return this.source ? (this.source.render(), this.transformDirty && (this.transformed ? this.source.cumulativeMatrix ? mat4.multiply(this.cumulativeMatrix, this.matrix, this.source.cumulativeMatrix) : mat4.copy(this.cumulativeMatrix, this.matrix) : mat4.copy(this.cumulativeMatrix, this.source.cumulativeMatrix || identity), this.transformDirty = !1), renderTransform && gl ? (this.renderDirty && (this.frameBuffer || (this.uniforms = {
				resolution: [this.width, this.height]
			}, this.frameBuffer = new FrameBuffer(gl, this.width, this.height)), this.uniforms.source = this.source.texture, this.uniforms.transform = this.cumulativeMatrix || identity, draw(baseShader, rectangleModel, this.uniforms, this.frameBuffer.frameBuffer, this), this.renderDirty = !1), this.texture = this.frameBuffer.texture) : this.source ? this.texture = this.source.texture : this.texture = null, this.dirty = !1, this.texture) : (this.transformDirty && (mat4.copy(this.cumulativeMatrix, this.matrix), this.transformDirty = !1), this.texture = null, void(this.dirty = !1))
		}, TransformNode.prototype.readPixels = function(x, y, width, height, dest) {
			var nodeGl = this.gl || gl;
			if (!gl) throw new Error("Cannot read pixels until a canvas is connected");
			if (this.render(!0), void 0 === dest) dest = new Uint8Array(width * height * 4);
			else if (!isInstance(dest, "Uint8Array")) throw new Error("Incompatible array type");
			return nodeGl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer.frameBuffer), nodeGl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, dest), dest
		}, TransformNode.prototype.destroy = function() {
			var i, key, item, hook = this.hook;
			for (i in this.plugin.destroy && "function" == typeof this.plugin.destroy && this.plugin.destroy.call(this), delete this.effect, this.frameBuffer && (this.frameBuffer.destroy(), delete this.frameBuffer, delete this.texture), this.inputElements) this.inputElements.hasOwnProperty(i) && ((item = this.inputElements[i]).element.removeEventListener("change", item.listener, !0), item.element.removeEventListener("input", item.listener, !0));
			for (this.source && this.source.removeTarget(this); this.targets.length;)(item = this.targets.pop()) && item.removeSource && item.removeSource(this);
			for (key in this) this.hasOwnProperty(key) && "id" !== key && delete this[key];
			for (key in aliases) aliases.hasOwnProperty(key) && (item = aliases[key]).node === this && seriously.removeAlias(key);
			0 <= (i = transforms.indexOf(this)) && transforms.splice(i, 1), 0 <= (i = allTransformsByHook[hook].indexOf(this)) && allTransformsByHook[hook].splice(i, 1), Node.prototype.destroy.call(this)
		}, TransformNode.prototype.setReady = Node.prototype.setReady, TransformNode.prototype.setUnready = Node.prototype.setUnready, TransformNode.prototype.on = Node.prototype.on, TransformNode.prototype.off = Node.prototype.off, TransformNode.prototype.emit = Node.prototype.emit, (options = isInstance(options, "HTMLCanvasElement") ? {
			canvas: options
		} : options || {}).canvas, this.effect = function(hook, options) {
			if (!seriousEffects[hook]) throw new Error("Unknown effect: " + hook);
			return new EffectNode(hook, options).pub
		}, this.source = function(hook, source, options) {
			return findInputNode(hook, source, options).pub
		}, this.transform = function(hook, opts) {
			if ("string" != typeof hook && (opts = hook, hook = !1), hook) {
				if (!seriousTransforms[hook]) throw new Error("Unknown transform: " + hook)
			} else if (hook = options && options.defaultTransform || "2d", !seriousTransforms[hook]) throw new Error("No transform specified");
			return new TransformNode(hook, opts).pub
		}, this.target = function(hook, target, options) {
			var targetNode, element, i;
			for (hook && "string" == typeof hook && !seriousTargets[hook] && (element = document.querySelector(hook)), ("string" != typeof hook || !target && 0 !== target || element) && (options && "object" == typeof options || (options = target), target = element || hook, hook = null), "string" == typeof target && isNaN(target) && (target = document.querySelector(target)), i = 0; i < targets.length; i++)
				if (targetNode = targets[i], (!hook || hook === targetNode.hook) && (targetNode.target === target || targetNode.compare && targetNode.compare(target, options))) return targetNode.pub;
			return (targetNode = new TargetNode(hook, target, options)).pub
		}, this.aliases = function() {
			return Object.keys(aliases)
		}, this.removeAlias = function(name) {
			aliases[name] && (delete this[name], delete aliases[name])
		}, this.defaults = function(hook, options) {
			var key;
			if (hook)
				if ("object" != typeof hook) null === options ? delete defaultInputs[hook] : "object" == typeof options && (defaultInputs[hook] = extend({}, options));
				else
					for (key in hook) hook.hasOwnProperty(key) && this.defaults(key, hook[key]);
			else if (null === hook)
				for (key in defaultInputs) defaultInputs.hasOwnProperty(key) && delete defaultInputs[key]
		}, this.go = function(pre, post) {
			var i;
			for ("function" == typeof pre && preCallbacks.indexOf(pre) < 0 && preCallbacks.push(pre), "function" == typeof post && postCallbacks.indexOf(post) < 0 && postCallbacks.push(post), auto = !0, i = 0; i < targets.length; i++) targets[i].go();
			rafId || !preCallbacks.length && !postCallbacks.length || renderDaemon()
		}, this.stop = function() {
			preCallbacks.length = 0, postCallbacks.length = 0, cancelAnimFrame(rafId), rafId = 0
		}, this.render = function() {
			var i;
			for (i = 0; i < targets.length; i++) targets[i].render(options)
		}, this.destroy = function() {
			for (var i, descriptor; nodes.length;) nodes[0].pub.destroy();
			for (i in this) this.hasOwnProperty(i) && "isDestroyed" !== i && "id" !== i && ((descriptor = Object.getOwnPropertyDescriptor(this, i)).get || descriptor.set || "function" != typeof this[i] ? delete this[i] : this[i] = nop);
			seriously = null, sources = [], targets = [], effects = [], nodes = [], preCallbacks.length = 0, postCallbacks.length = 0, cancelAnimFrame(rafId), isDestroyed = !(rafId = 0)
		}, this.isDestroyed = function() {
			return isDestroyed
		}, this.incompatible = function(hook) {
			var key, plugin, failure;
			if (failure = Seriously.incompatible(hook)) return failure;
			if (!hook) {
				for (key in allEffectsByHook)
					if (allEffectsByHook.hasOwnProperty(key) && allEffectsByHook[key].length && (plugin = seriousEffects[key]) && "function" == typeof plugin.compatible && !plugin.compatible.call(this)) return "plugin-" + key;
				for (key in allSourcesByHook)
					if (allSourcesByHook.hasOwnProperty(key) && allSourcesByHook[key].length && (plugin = seriousSources[key]) && "function" == typeof plugin.compatible && !plugin.compatible.call(this)) return "source-" + key
			}
			return !1
		}, this.isNode = function(candidate) {
			var node;
			return !(!candidate || !(node = nodesById[candidate.id]) || node.isDestroyed)
		}, this.isSource = function(candidate) {
			return this.isNode(candidate) && candidate instanceof Source
		}, this.isEffect = function(candidate) {
			return this.isNode(candidate) && candidate instanceof Effect
		}, this.isTransform = function(candidate) {
			return this.isNode(candidate) && candidate instanceof Transform
		}, this.isTarget = function(candidate) {
			return this.isNode(candidate) && candidate instanceof Target
		}, Object.defineProperties(this, {
			id: {
				enumerable: !0,
				configurable: !0,
				get: function() {
					return id
				}
			}
		}), this.defaults(options.defaults)
	}
	return window.addEventListener("message", function(event) {
		event.source === window && "seriously-timeout-message" === event.data && (event.stopPropagation(), 0 < timeouts.length && timeouts.shift()())
	}, !0), FrameBuffer.prototype.resize = function(width, height) {
		var gl = this.gl;
		this.width === width && this.height === height || (this.width = width, this.height = height, gl && (gl.bindTexture(gl.TEXTURE_2D, this.texture), gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer), gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null), gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height), gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0), gl.bindTexture(gl.TEXTURE_2D, null), gl.bindRenderbuffer(gl.RENDERBUFFER, null), gl.bindFramebuffer(gl.FRAMEBUFFER, null)))
	}, FrameBuffer.prototype.destroy = function() {
		var gl = this.gl;
		gl && (gl.deleteFramebuffer(this.frameBuffer), gl.deleteRenderbuffer(this.renderBuffer), this.ownTexture && gl.deleteTexture(this.texture)), delete this.frameBuffer, delete this.renderBuffer, delete this.texture, delete this.gl
	}, ShaderProgram.prototype.use = function() {
		this.gl.useProgram(this.program)
	}, Seriously.incompatible = function(hook) {
		var canvas, gl, plugin;
		if (void 0 === incompatibility && ((canvas = document.createElement("canvas")) && canvas.getContext ? window.WebGLRenderingContext ? (gl = getTestContext()) || (incompatibility = "context") : incompatibility = "webgl" : incompatibility = "canvas"), incompatibility) return incompatibility;
		if (hook) {
			if ((plugin = seriousEffects[hook]) && "function" == typeof plugin.compatible && !plugin.compatible(gl)) return "plugin-" + hook;
			if ((plugin = seriousSources[hook]) && "function" == typeof plugin.compatible && !plugin.compatible(gl)) return "source-" + hook
		}
		return !1
	}, Seriously.plugin = function(hook, definition, meta) {
		var effect;
		if (seriousEffects[hook]) Seriously.logger.warn("Effect [" + hook + "] already loaded");
		else if (void 0 === meta && "object" == typeof definition && (meta = definition), meta) return effect = extend({}, meta), "function" == typeof definition && (effect.definition = definition), effect.reserved = reservedEffectProperties, effect.inputs && validateInputSpecs(effect), effect.title || (effect.title = hook), seriousEffects[hook] = effect, allEffectsByHook[hook] = [], effect
	}, Seriously.removePlugin = function(hook) {
		var all;
		if (!hook) return this;
		if (!seriousEffects[hook]) return this;
		if (all = allEffectsByHook[hook]) {
			for (; all.length;) all.shift().destroy();
			delete allEffectsByHook[hook]
		}
		return delete seriousEffects[hook], this
	}, Seriously.source = function(hook, definition, meta) {
		var source;
		if (seriousSources[hook]) Seriously.logger.warn("Source [" + hook + "] already loaded");
		else if (void 0 === meta && "object" == typeof definition && (meta = definition), meta || definition) return source = extend({}, meta), "function" == typeof definition && (source.definition = definition), source.title || (source.title = hook), seriousSources[hook] = source, allSourcesByHook[hook] = [], source
	}, Seriously.removeSource = function(hook) {
		var all;
		if (!hook) return this;
		if (!seriousSources[hook]) return this;
		if (all = allSourcesByHook[hook]) {
			for (; all.length;) all.shift().destroy();
			delete allSourcesByHook[hook]
		}
		return delete seriousSources[hook], this
	}, Seriously.transform = function(hook, definition, meta) {
		var transform;
		if (seriousTransforms[hook]) Seriously.logger.warn("Transform [" + hook + "] already loaded");
		else if (void 0 === meta && "object" == typeof definition && (meta = definition), meta || definition) return transform = extend({}, meta), "function" == typeof definition && (transform.definition = definition), transform.reserved = reservedTransformProperties, transform.inputs && validateInputSpecs(transform), transform.title || (transform.title = hook), seriousTransforms[hook] = transform, allTransformsByHook[hook] = [], transform
	}, Seriously.removeTransform = function(hook) {
		var all;
		if (!hook) return this;
		if (!seriousTransforms[hook]) return this;
		if (all = allTransformsByHook[hook]) {
			for (; all.length;) all.shift().destroy();
			delete allTransformsByHook[hook]
		}
		return delete seriousTransforms[hook], this
	}, Seriously.target = function(hook, definition, meta) {
		var target;
		if (seriousTargets[hook]) Seriously.logger.warn("Target [" + hook + "] already loaded");
		else if (void 0 === meta && "object" == typeof definition && (meta = definition), meta || definition) return target = extend({}, meta), "function" == typeof definition && (target.definition = definition), target.title || (target.title = hook), seriousTargets[hook] = target, allTargetsByHook[hook] = [], target
	}, Seriously.removeTarget = function(hook) {
		var all;
		if (!hook) return this;
		if (!seriousTargets[hook]) return this;
		if (all = allTargetsByHook[hook]) {
			for (; all.length;) all.shift().destroy();
			delete allTargetsByHook[hook]
		}
		return delete seriousTargets[hook], this
	}, Seriously.inputValidators = {
		color: function(value, input, defaultValue, oldValue) {
			var s, a, match, i;
			if (a = oldValue || [], "string" == typeof value) {
				if ((match = colorRegex.exec(value)) && match.length) {
					if (match.length < 3) return a[0] = a[1] = a[2] = a[3] = 0, a;
					for (a[3] = 1, i = 0; i < 3; i++) a[i] = parseFloat(match[i + 2]) / 255;
					return isNaN(match[6]) || (a[3] = parseFloat(match[6])), "hsl" === match[1].toLowerCase() ? hslToRgb(a[0], a[1], a[2], a[3], a) : a
				}
				if ((match = hexColorRegex.exec(value)) && match.length) return 3 === (s = match[1]).length ? (a[0] = parseInt(s[0], 16) / 15, a[1] = parseInt(s[1], 16) / 15, a[2] = parseInt(s[2], 16) / 15, a[3] = 1) : 4 === s.length ? (a[0] = parseInt(s[0], 16) / 15, a[1] = parseInt(s[1], 16) / 15, a[2] = parseInt(s[2], 16) / 15, a[3] = parseInt(s[3], 16) / 15) : 6 === s.length ? (a[0] = parseInt(s.substr(0, 2), 16) / 255, a[1] = parseInt(s.substr(2, 2), 16) / 255, a[2] = parseInt(s.substr(4, 2), 16) / 255, a[3] = 1) : 8 === s.length ? (a[0] = parseInt(s.substr(0, 2), 16) / 255, a[1] = parseInt(s.substr(2, 2), 16) / 255, a[2] = parseInt(s.substr(4, 2), 16) / 255, a[3] = parseInt(s.substr(6, 2), 16) / 255) : a[0] = a[1] = a[2] = a[3] = 0, a;
				if (match = colorNames[value.toLowerCase()]) {
					for (i = 0; i < 4; i++) a[i] = match[i];
					return a
				}
				return colorCtx || (colorCtx = document.createElement("canvas").getContext("2d")), colorCtx.fillStyle = value, (s = colorCtx.fillStyle) && "#000000" !== s ? Seriously.inputValidators.color(s, input, defaultValue, oldValue) : (a[0] = a[1] = a[2] = a[3] = 0, a)
			}
			if (isArrayLike(value)) {
				if ((a = value).length < 3) return a[0] = a[1] = a[2] = a[3] = 0, a;
				for (i = 0; i < 3; i++)
					if (isNaN(a[i])) return a[0] = a[1] = a[2] = a[3] = 0, a;
				return a.length < 4 && a.push(1), a
			}
			if ("number" == typeof value) return a[0] = a[1] = a[2] = value, a[3] = 1, a;
			if ("object" != typeof value) return a[0] = a[1] = a[2] = a[3] = 0, a;
			for (i = 0; i < 4; i++) null === value[s = colorFields[i]] || isNaN(value[s]) ? a[i] = 3 === i ? 1 : 0 : a[i] = value[s];
			return a
		},
		number: function(value, input, defaultValue) {
			return value = parseFloat(value), isNaN(value) ? defaultValue || 0 : (input.mod && (value -= input.mod * Math.floor(value / input.mod)), value < input.min ? input.min : value > input.max ? input.max : input.step ? Math.round(value / input.step) * input.step : value)
		},
		enum: function(value, input, defaultValue) {
			var options = input.options || [];
			return "string" == typeof value ? value = value.toLowerCase() : "number" == typeof value ? value = value.toString() : value || (value = ""), options.hasOwnProperty(value) ? value : defaultValue || ""
		},
		vector: function(value, input, defaultValue, oldValue) {
			var a, i, s, n = input.dimensions || 4;
			if (a = oldValue || [], isArrayLike(value)) {
				for (i = 0; i < n; i++) a[i] = value[i] || 0;
				return a
			}
			if ("object" == typeof value) {
				for (i = 0; i < n; i++) void 0 === value[s = vectorFields[i]] && (s = colorFields[i]), a[i] = value[s] || 0;
				return a
			}
			for (value = parseFloat(value) || 0, i = 0; i < n; i++) a[i] = value;
			return a
		},
		boolean: function(value) {
			return !!value && (!value || !value.toLowerCase || "false" !== value.toLowerCase())
		},
		string: function(value) {
			return "string" == typeof value ? value : 0 === value || value ? value.toString ? value.toString() : String(value) : ""
		}
	}, Seriously.prototype.effects = Seriously.effects = function() {
		var name, effect, manifest, input, i, effects = {};
		for (name in seriousEffects)
			if (seriousEffects.hasOwnProperty(name)) {
				for (i in manifest = {
						title: (effect = seriousEffects[name]).title || name,
						description: effect.description || "",
						inputs: {}
					}, effect.inputs) effect.inputs.hasOwnProperty(i) && (input = effect.inputs[i], manifest.inputs[i] = {
					type: input.type,
					defaultValue: input.defaultValue,
					step: input.step,
					min: input.min,
					max: input.max,
					mod: input.mod,
					minCount: input.minCount,
					maxCount: input.maxCount,
					dimensions: input.dimensions,
					title: input.title || i,
					description: input.description || "",
					options: input.options || []
				});
				effects[name] = manifest
			}
		return effects
	}, window.Float32Array && (identity = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])), window.Seriously && "object" == typeof window.Seriously && function() {
		var i;
		for (i in window.Seriously) window.Seriously.hasOwnProperty(i) && "plugin" !== i && "object" == typeof window.Seriously[i] && Seriously.plugin(i, window.Seriously[i])
	}(), Seriously.logger = {
		log: consoleMethod("log"),
		info: consoleMethod("info"),
		warn: consoleMethod("warn"),
		error: consoleMethod("error")
	}, Seriously.util = {
		mat4: mat4,
		checkSource: function(source) {
			var element, canvas, ctx, texture;
			if (!(element = getElement(source, ["img", "canvas", "video"]))) return !1;
			if (!(canvas = document.createElement("canvas"))) return Seriously.logger.warn("Browser does not support canvas or Seriously.js"), !1;
			if (0 === element.naturalWidth && "IMG" === element.tagName) return Seriously.logger.warn("Image not loaded"), !1;
			if (0 === element.readyState && 0 === element.videoWidth && "VIDEO" === element.tagName) return Seriously.logger.warn("Video not loaded"), !1;
			if (ctx = getTestContext()) {
				(texture = ctx.createTexture()) || Seriously.logger.error("Test WebGL context has been lost"), ctx.bindTexture(ctx.TEXTURE_2D, texture);
				try {
					ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, ctx.RGBA, ctx.UNSIGNED_BYTE, element)
				} catch (textureError) {
					return textureError.code === window.DOMException.SECURITY_ERR ? Seriously.logger.log("Unable to access cross-domain image") : Seriously.logger.error("Error storing image to texture: " + textureError.message), ctx.deleteTexture(texture), !1
				}
				ctx.deleteTexture(texture)
			} else {
				ctx = canvas.getContext("2d");
				try {
					ctx.drawImage(element, 0, 0), ctx.getImageData(0, 0, 1, 1)
				} catch (drawImageError) {
					return drawImageError.code === window.DOMException.SECURITY_ERR ? Seriously.logger.log("Unable to access cross-domain image") : Seriously.logger.error("Error drawing image to canvas: " + drawImageError.message), !1
				}
			}
			return !0
		},
		hslToRgb: hslToRgb,
		colors: colorNames,
		setTimeoutZero: setTimeoutZero,
		ShaderProgram: ShaderProgram,
		FrameBuffer: FrameBuffer,
		requestAnimationFrame: requestAnimationFrame,
		shader: {
			makeNoise: "float makeNoise(float u, float v, float timer) {\n\tfloat x = u * v * mod(timer * 1000.0, 100.0);\n\tx = mod(x, 13.0) * mod(x, 127.0);\n\tfloat dx = mod(x, 0.01);\n\treturn clamp(0.1 + dx * 100.0, 0.0, 1.0);\n}\n",
			random: "#ifndef RANDOM\n#define RANDOM\nfloat random(vec2 n) {\n\treturn 0.5 + 0.5 * fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n#endif\n"
		}
	}, Seriously.source("video", function(video, options, force) {
		var canvas, ctx2d, me = this,
			destroyed = !1,
			deferTexture = !1,
			isSeeking = !1,
			lastRenderTime = 0;

		function initializeVideo() {
			video.removeEventListener("loadedmetadata", initializeVideo, !0), destroyed || (video.videoWidth ? (me.width === video.videoWidth && me.height === video.videoHeight || (me.width = video.videoWidth, me.height = video.videoHeight, me.resize()), deferTexture && me.setReady()) : (deferTexture = !0, setTimeout(initializeVideo, 50)))
		}

		function seeking() {
			isSeeking = !0
		}

		function seeked() {
			isSeeking = !1, me.setDirty()
		}
		if (isInstance(video, "HTMLVideoElement")) return video.readyState ? initializeVideo() : (deferTexture = !0, video.addEventListener("loadedmetadata", initializeVideo, !0)), video.addEventListener("seeking", seeking, !1), video.addEventListener("seeked", seeked, !1), {
			deferTexture: deferTexture,
			source: video,
			render: function renderVideo(gl) {
				var source;
				if (lastRenderTime = video.currentTime, !video.videoHeight || !video.videoWidth) return !1;
				noVideoTextureSupport ? (ctx2d || (ctx2d = document.createElement("canvas").getContext("2d"), (canvas = ctx2d.canvas).width = me.width, canvas.height = me.height), source = canvas, ctx2d.drawImage(video, 0, 0, me.width, me.height)) : source = video, gl.bindTexture(gl.TEXTURE_2D, me.texture), gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, me.flip), gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1);
				try {
					if (gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source), void 0 === noVideoTextureSupport) {
						if (gl.getError() === gl.INVALID_VALUE) return noVideoTextureSupport = !0, renderVideo(gl);
						noVideoTextureSupport = !1
					}
					return !0
				} catch (securityError) {
					securityError.code === window.DOMException.SECURITY_ERR ? (me.allowRefresh = !1, Seriously.logger.error("Unable to access cross-domain image")) : Seriously.logger.error("Error rendering video source", securityError)
				}
				return !1
			},
			checkDirty: function() {
				return !isSeeking && video.currentTime !== lastRenderTime
			},
			compare: function(source) {
				return me.source === source
			},
			destroy: function() {
				destroyed = !0, video.removeEventListener("seeking", seeking, !1), video.removeEventListener("seeked", seeked, !1), video.removeEventListener("loadedmetadata", initializeVideo, !0)
			}
		}
	}, {
		title: "Video"
	}), Seriously.transform("2d", function(options) {
		var me = this,
			degrees = !(options && options.radians),
			centerX = 0,
			centerY = 0,
			scaleX = 1,
			scaleY = 1,
			translateX = 0,
			translateY = 0,
			rotation = 0,
			skewX = 0,
			skewY = 0;

		function recompute() {
			var angle, s, c, m00, m01, m02, m03, m10, m11, m12, m13, matrix = me.matrix;

			function translate(x, y) {
				matrix[12] = matrix[0] * x + matrix[4] * y + matrix[12], matrix[13] = matrix[1] * x + matrix[5] * y + matrix[13], matrix[14] = matrix[2] * x + matrix[6] * y + matrix[14], matrix[15] = matrix[3] * x + matrix[7] * y + matrix[15]
			}
			me.transformed = !!(translateX || translateY || rotation || skewX || skewY || 1 !== scaleX || 1 !== scaleY) && (mat4.identity(matrix), translate(translateX + centerX, translateY + centerY), skewX && (matrix[4] = skewX / me.width), skewY && (matrix[1] = skewY / me.height), rotation && (m00 = matrix[0], m01 = matrix[1], m02 = matrix[2], m03 = matrix[3], m10 = matrix[4], m11 = matrix[5], m12 = matrix[6], m13 = matrix[7], angle = -(degrees ? rotation * Math.PI / 180 : rotation), s = Math.sin(angle), c = Math.cos(angle), matrix[0] = m00 * c + m10 * s, matrix[1] = m01 * c + m11 * s, matrix[2] = m02 * c + m12 * s, matrix[3] = m03 * c + m13 * s, matrix[4] = m10 * c - m00 * s, matrix[5] = m11 * c - m01 * s, matrix[6] = m12 * c - m02 * s, matrix[7] = m13 * c - m03 * s), 1 !== scaleX && (matrix[0] *= scaleX, matrix[1] *= scaleX, matrix[2] *= scaleX, matrix[3] *= scaleX), 1 !== scaleY && (matrix[4] *= scaleY, matrix[5] *= scaleY, matrix[6] *= scaleY, matrix[7] *= scaleY), translate(-centerX, -centerY), !0)
		}
		return {
			inputs: {
				reset: {
					method: function() {
						return scaleY = scaleX = 1, skewY = skewX = rotation = translateY = translateX = centerY = centerX = 0, !!me.transformed && !(me.transformed = !1)
					}
				},
				translate: {
					method: function(x, y) {
						return isNaN(x) && (x = translateX), isNaN(y) && (y = translateY), (x !== translateX || y !== translateY) && (translateX = x, translateY = y, recompute(), !0)
					},
					type: ["number", "number"]
				},
				translateX: {
					get: function() {
						return translateX
					},
					set: function(x) {
						return x !== translateX && (translateX = x, recompute(), !0)
					},
					type: "number"
				},
				translateY: {
					get: function() {
						return translateY
					},
					set: function(y) {
						return y !== translateY && (translateY = y, recompute(), !0)
					},
					type: "number"
				},
				rotation: {
					get: function() {
						return rotation
					},
					set: function(angle) {
						return angle !== rotation && (rotation = parseFloat(angle), recompute(), !0)
					},
					type: "number"
				},
				center: {
					method: function(x, y) {
						return isNaN(x) && (x = centerX), isNaN(y) && (y = centerY), (x !== centerX || y !== centerY) && (centerX = x, centerY = y, recompute(), !0)
					},
					type: ["number", "number"]
				},
				centerX: {
					get: function() {
						return centerX
					},
					set: function(x) {
						return x !== centerX && (centerX = x, recompute(), !0)
					},
					type: "number"
				},
				centerY: {
					get: function() {
						return centerY
					},
					set: function(y) {
						return y !== centerY && (centerY = y, recompute(), !0)
					},
					type: "number"
				},
				skew: {
					method: function(x, y) {
						return isNaN(x) && (x = skewX), isNaN(y) && (y = skewY), (x !== skewX || y !== skewY) && (skewX = x, skewY = y, recompute(), !0)
					},
					type: ["number", "number"]
				},
				skewX: {
					get: function() {
						return skewX
					},
					set: function(x) {
						return x !== skewX && (skewX = x, recompute(), !0)
					},
					type: "number"
				},
				skewY: {
					get: function() {
						return skewY
					},
					set: function(y) {
						return y !== skewY && (skewY = y, recompute(), !0)
					},
					type: "number"
				},
				scale: {
					method: function(x, y) {
						var newX, newY;
						if (newX = isNaN(x) ? scaleX : x, isNaN(y)) {
							if (isNaN(x)) return !1;
							newY = newX
						} else newY = y;
						return (newX !== scaleX || newY !== scaleY) && (scaleX = newX, scaleY = newY, recompute(), !0)
					},
					type: ["number", "number"]
				},
				scaleX: {
					get: function() {
						return scaleX
					},
					set: function(x) {
						return x !== scaleX && (scaleX = x, recompute(), !0)
					},
					type: "number"
				},
				scaleY: {
					get: function() {
						return scaleY
					},
					set: function(y) {
						return y !== scaleY && (scaleY = y, recompute(), !0)
					},
					type: "number"
				}
			}
		}
	}, {
		title: "2D Transform",
		description: "Translate, Rotate, Scale, Skew"
	}), Seriously.transform("flip", function() {
		var me = this,
			horizontal = !0;

		function recompute() {
			var matrix = me.matrix;
			matrix[5] = horizontal ? (matrix[0] = -1, 1) : -(matrix[0] = 1)
		}
		return mat4.identity(me.matrix), recompute(), me.transformDirty = !0, me.transformed = !0, {
			inputs: {
				direction: {
					get: function() {
						return horizontal ? "horizontal" : "vertical"
					},
					set: function(d) {
						var horiz;
						return (horiz = "vertical" !== d) !== horizontal && (horizontal = horiz, recompute(), !0)
					},
					type: "string"
				}
			}
		}
	}, {
		title: "Flip",
		description: "Flip Horizontal/Vertical"
	}), Seriously.transform("reformat", function() {
		var forceWidth, forceHeight, me = this,
			mode = "contain";

		function recompute() {
			var scaleX, scaleY, aspectIn, aspectOut, matrix = me.matrix,
				width = forceWidth || me.width,
				height = forceHeight || me.height,
				source = me.source,
				sourceWidth = source && source.width || 1,
				sourceHeight = source && source.height || 1;
			me.transformed = "distort" !== mode && (width !== sourceWidth || height !== sourceHeight) && (aspectIn = sourceWidth / sourceHeight, aspectOut = width / height, scaleY = "none" === mode ? (scaleX = sourceWidth / width, sourceHeight / height) : "width" === mode || "contain" === mode && aspectOut <= aspectIn ? (scaleX = 1, aspectOut / aspectIn) : "height" === mode || "contain" === mode && aspectIn < aspectOut ? (scaleX = aspectIn / aspectOut, 1) : aspectIn < aspectOut ? (scaleX = 1, aspectOut / aspectIn) : (scaleX = aspectIn / aspectOut, 1), (1 !== scaleX || 1 !== scaleY) && (mat4.identity(matrix), 1 !== scaleX && (matrix[0] *= scaleX, matrix[1] *= scaleX, matrix[2] *= scaleX, matrix[3] *= scaleX), 1 !== scaleY && (matrix[4] *= scaleY, matrix[5] *= scaleY, matrix[6] *= scaleY, matrix[7] *= scaleY), !0))
		}

		function getWidth() {
			return forceWidth || me.source && me.source.width || 1
		}

		function getHeight() {
			return forceHeight || me.source && me.source.height || 1
		}
		return this.resize = function() {
			var i, width = getWidth(),
				height = getHeight();
			if (this.width !== width || this.height !== height)
				for (this.width = width, this.height = height, this.uniforms && this.uniforms.resolution && (this.uniforms.resolution[0] = width, this.uniforms.resolution[1] = height), this.frameBuffer && this.frameBuffer.resize && this.frameBuffer.resize(width, height), i = 0; i < this.targets.length; i++) this.targets[i].resize();
			this.setTransformDirty(), recompute()
		}, {
			inputs: {
				width: {
					get: getWidth,
					set: function(x) {
						return (x = Math.floor(x)) === forceWidth || (forceWidth = x, this.resize()), !1
					},
					type: "number"
				},
				height: {
					get: getHeight,
					set: function(y) {
						return (y = Math.floor(y)) === forceHeight || (forceHeight = y, this.resize()), !1
					},
					type: "number"
				},
				mode: {
					get: function() {
						return mode
					},
					set: function(m) {
						return m !== mode && (mode = m, recompute(), !0)
					},
					type: "enum",
					options: ["cover", "contain", "distort", "width", "height", "none"]
				}
			}
		}
	}, {
		title: "Reformat",
		description: "Change output dimensions"
	}), baseVertexShader = ["precision mediump float;", "attribute vec4 position;", "attribute vec2 texCoord;", "uniform vec2 resolution;", "uniform mat4 transform;", "varying vec2 vTexCoord;", "void main(void) {", "\tvec4 screenPosition = vec4(position.xy * resolution / 2.0, position.z, position.w);", "\tscreenPosition = transform * screenPosition;", "\tgl_Position.xy = screenPosition.xy * 2.0 / resolution;", "\tgl_Position.z = screenPosition.z * 2.0 / (resolution.x / resolution.y);", "\tgl_Position.w = screenPosition.w;", "\tvTexCoord = texCoord;", "}\n"].join("\n"), baseFragmentShader = ["precision mediump float;", "varying vec2 vTexCoord;", "uniform sampler2D source;", "void main(void) {", "\t\tgl_FragColor = texture2D(source, vTexCoord);", "}"].join("\n"), Seriously.util.shader.noiseHelpers = "#ifndef NOISE_HELPERS\n#define NOISE_HELPERS\nvec2 mod289(vec2 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec3 mod289(vec3 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec3 permute(vec3 x) {\n\treturn mod289(((x*34.0)+1.0)*x);\n}\nvec4 permute(vec4 x) {\n\treturn mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat taylorInvSqrt(float r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n#endif\n", Seriously.util.shader.snoise2d = "#ifndef NOISE2D\n#define NOISE2D\nfloat snoise(vec2 v) {\n\tconst vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\n\t\t0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n\t\t-0.577350269189626, // -1.0 + 2.0 * C.x\n\t\t0.024390243902439); // 1.0 / 41.0\n\tvec2 i = floor(v + dot(v, C.yy));\n\tvec2 x0 = v - i + dot(i, C.xx);\n\tvec2 i1;\n\t//i1.x = step(x0.y, x0.x); // x0.x > x0.y ? 1.0 : 0.0\n\t//i1.y = 1.0 - i1.x;\n\ti1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\t// x0 = x0 - 0.0 + 0.0 * C.xx ;\n\t// x1 = x0 - i1 + 1.0 * C.xx ;\n\t// x2 = x0 - 1.0 + 2.0 * C.xx ;\n\tvec4 x12 = x0.xyxy + C.xxzz;\n\tx12.xy -= i1;\n\ti = mod289(i); // Avoid truncation effects in permutation\n\tvec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n\tvec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n\tm = m*m ;\n\tm = m*m ;\n\tvec3 x = 2.0 * fract(p * C.www) - 1.0;\n\tvec3 h = abs(x) - 0.5;\n\tvec3 ox = floor(x + 0.5);\n\tvec3 a0 = x - ox;\n\tm *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\n\tvec3 g;\n\tg.x = a0.x * x0.x + h.x * x0.y;\n\tg.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\treturn 130.0 * dot(m, g);\n}\n#endif\n", Seriously.util.shader.snoise3d = "#ifndef NOISE3D\n#define NOISE3D\nfloat snoise(vec3 v) {\n\tconst vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n\tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\tvec3 i = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx) ;\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\t// x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t// x1 = x0 - i1 + 1.0 * C.xxx;\n\t// x2 = x0 - i2 + 2.0 * C.xxx;\n\t// x3 = x0 - 1.0 + 3.0 * C.xxx;\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\ti = mod289(i);\n\tvec4 p = permute(permute(permute(\n\t\t\t\t\t\ti.z + vec4(0.0, i1.z, i2.z, 1.0))\n\t\t\t\t\t\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0))\n\t\t\t\t\t\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3 ns = n_ * D.wyz - D.xzx;\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p, 7 * 7)\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_); // mod(j, N)\n\tvec4 x = x_ * ns.x + ns.yyyy;\n\tvec4 y = y_ * ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\t//vec4 s0 = vec4(lessThan(b0, 0.0)) * 2.0 - 1.0;\n\t//vec4 s1 = vec4(lessThan(b1, 0.0)) * 2.0 - 1.0;\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\tvec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n\tm = m * m;\n\treturn 42.0 * dot(m*m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n}\n#endif\n", Seriously.util.shader.snoise4d = "#ifndef NOISE4D\n#define NOISE4D\nvec4 grad4(float j, vec4 ip)\n\t{\n\tconst vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n\tvec4 p, s;\n\n\tp.xyz = floor(fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n\tp.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n\ts = vec4(lessThan(p, vec4(0.0)));\n\tp.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n\treturn p;\n\t}\n\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n\t{\n\tconst vec4 C = vec4(0.138196601125011, // (5 - sqrt(5))/20 G4\n\t\t\t\t\t\t0.276393202250021, // 2 * G4\n\t\t\t\t\t\t0.414589803375032, // 3 * G4\n\t\t\t\t\t\t-0.447213595499958); // -1 + 4 * G4\n\n\tvec4 i = floor(v + dot(v, vec4(F4)));\n\tvec4 x0 = v - i + dot(i, C.xxxx);\n\n\n\tvec4 i0;\n\tvec3 isX = step(x0.yzw, x0.xxx);\n\tvec3 isYZ = step(x0.zww, x0.yyz);\n\ti0.x = isX.x + isX.y + isX.z;\n\ti0.yzw = 1.0 - isX;\n\ti0.y += isYZ.x + isYZ.y;\n\ti0.zw += 1.0 - isYZ.xy;\n\ti0.z += isYZ.z;\n\ti0.w += 1.0 - isYZ.z;\n\n\tvec4 i3 = clamp(i0, 0.0, 1.0);\n\tvec4 i2 = clamp(i0 - 1.0, 0.0, 1.0);\n\tvec4 i1 = clamp(i0 - 2.0, 0.0, 1.0);\n\n\tvec4 x1 = x0 - i1 + C.xxxx;\n\tvec4 x2 = x0 - i2 + C.yyyy;\n\tvec4 x3 = x0 - i3 + C.zzzz;\n\tvec4 x4 = x0 + C.wwww;\n\n\ti = mod289(i);\n\tfloat j0 = permute(permute(permute(permute(i.w) + i.z) + i.y) + i.x);\n\tvec4 j1 = permute(permute(permute(permute (\n\t\t\t\t\ti.w + vec4(i1.w, i2.w, i3.w, 1.0))\n\t\t\t\t\t+ i.z + vec4(i1.z, i2.z, i3.z, 1.0))\n\t\t\t\t\t+ i.y + vec4(i1.y, i2.y, i3.y, 1.0))\n\t\t\t\t\t+ i.x + vec4(i1.x, i2.x, i3.x, 1.0));\n\n\tvec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n\tvec4 p0 = grad4(j0, ip);\n\tvec4 p1 = grad4(j1.x, ip);\n\tvec4 p2 = grad4(j1.y, ip);\n\tvec4 p3 = grad4(j1.z, ip);\n\tvec4 p4 = grad4(j1.w, ip);\n\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\tp4 *= taylorInvSqrt(dot(p4, p4));\n\n\tvec3 m0 = max(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n\tvec2 m1 = max(0.6 - vec2(dot(x3, x3), dot(x4, x4)), 0.0);\n\tm0 = m0 * m0;\n\tm1 = m1 * m1;\n\treturn 49.0 * (dot(m0*m0, vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2)))\n\t\t\t\t\t\t\t+ dot(m1*m1, vec2(dot(p3, x3), dot(p4, x4)))) ;\n}\n#endif\n", Seriously
});